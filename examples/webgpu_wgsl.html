<html lang="en">
	<head>
		<title>three.js - shadertoy</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - WGSL/TSL Interoperability
			<br />Shader adapted from <a href="https://mini.gmshaders.com/p/gm-shaders-mini-crt" target="_blank" rel="noopener"> Xor</a>.
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import * as Nodes from 'three/nodes';

			import Transpiler from './jsm/transpiler/Transpiler.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGL from 'three/addons/capabilities/WebGL.js';

			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
      import { tslFn, uniform, wgslFn, color, texture, uv, clamp, float, vec2, vec3, vec4, fract, floor, MeshBasicNodeMaterial} from 'three/nodes';

      import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let renderer, camera, scene;
			const dpr = window.devicePixelRatio;


      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {
        
        renderer.render( scene, camera );
        
      }

			function init() {

				if ( WebGPU.isAvailable() === false && WebGL.isWebGL2Available() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw new Error( 'No WebGPU or WebGL2 support' );

				}


        const crtWGSLFn = wgslFn(`
          fn crt(
            uv: vec2<f32>,
            tex: texture_2d<f32>,
            tex_sampler: sampler,
            canvasWidth: f32, 
            canvasHeight: f32,
            cellOffset: f32,
            cellSize: f32, 
            borderMask: f32
          ) -> vec3<f32> {

            // Convert uv into map of pixels
            var pixel = (uv * 0.5 + 0.5) * vec2<f32>(
              canvasWidth, 
              canvasHeight
            );

            // Coordinate for each cell in the pixel map
            var coord = pixel / cellSize;
            // Three color values for each cell (r, g, b)
            var subcoord = coord * vec2f(3.0, 1.0);

            var cell_offset = vec2<f32>(0, fract(floor(coord.x) * cellOffset));

            var mask_coord = floor(coord + cell_offset) * cellSize;

            var samplePoint = mask_coord / vec2<f32>(canvasWidth, canvasHeight);

            var color = textureSample(
              tex,
              tex_sampler,
              samplePoint
            ).xyz;

            //current implementation does not give an even amount of space to each r, g, b unit of a cell
            //Fix/hack this by multiplying subCoord.x by cellSize at cellSizes below 6
            var ind = floor(subcoord.x) % 3;

            var mask_color = vec3<f32>(
              f32(ind == 0.0), 
              f32(ind == 1.0), 
              f32(ind == 2.0)
            ) * 3.0;
            
            var cell_uv = fract(subcoord + cell_offset) * 2.0 - 1.0;
            var border: vec2<f32> = 1.0 - cell_uv * cell_uv * borderMask;
            
            mask_color *= vec3f(clamp(border.x, 0.0, 1.0) * clamp(border.y, 0.0, 1.0));
            
            color *= mask_color;

            return color;
          }
        `);


        const textureLoader = new THREE.TextureLoader();
        const lavaTexture = textureLoader.load( 'textures/lava/lavatile.jpg' );
        lavaTexture.wrapS = THREE.RepeatWrapping;
        lavaTexture.wrapT = THREE.RepeatWrapping;

        const lavaTextureNode = texture(lavaTexture);

        const canvasWidthUniform = uniform(600);
        const canvasHeightUniform = uniform(600);
        const cellOffsetUniform = uniform(0.5);
        const cellSizeUniform = uniform(6)
        const borderMaskUniform = uniform(1);

        const wgslShaderMaterial = new MeshBasicNodeMaterial();
        wgslShaderMaterial.colorNode = crtWGSLFn( {
          uv: uv(),
          tex: lavaTextureNode,
          tex_sampler: lavaTextureNode,
          canvasWidth: canvasWidthUniform,
          canvasHeight: canvasHeightUniform,
          cellOffset: cellOffsetUniform,
          cellSize: cellSizeUniform,
          borderMask: borderMaskUniform
        });


        const crtTSLFn = tslFn(() => {
          const dimensions = vec2(canvasWidthUniform, canvasHeightUniform);
          const translatedUV = uv().mul(0.5).add(0.5);
          const pixel = translatedUV.mul(dimensions);
        
          const coord = pixel.div(cellSizeUniform);
          const subCoord = coord.mul(vec2(3.0, 1.0));
          
          const cellOffset = vec2(
            0.0, 
            fract(floor(coord.x).mul(cellOffsetUniform))
          )
        
          const maskCoord = floor(coord.add(cellOffset)).mul(cellSizeUniform);
          const samplePoint = maskCoord.div(dimensions);
        
          let color = texture(lavaTexture, samplePoint);
        
          const ind = floor(subCoord.x).mod(3);

          const red = ind.equal(0.0);
          const green = ind.equal(1.0);
          const blue = ind.equal(2.0)
        
          let maskColor = vec3(
            ind.equal(0.0), 
            ind.equal(1.0), 
            ind.equal(2.0)
          ).mul(3.0);
        
          const subCoordOffset = fract(subCoord.add(cellOffset));
          console.log(subCoord.x, subCoord.y)
          let cellUV = subCoordOffset.mul(2.0);
          cellUV = cellUV.sub(1.0);
        
          const border = float(1.0).sub(
            cellUV.mul(cellUV).mul(borderMaskUniform)
          );
        
          const clampX = clamp(border.x, 0.0, 1.0)
          const clampY = clamp(border.y, 0.0, 1.0);
          const borderClamp = clampX.mul(clampY);
          maskColor = maskColor.mul(borderClamp);

          color = color.mul(maskColor);
          return color;
        })


        const tslShaderMaterial = new MeshBasicNodeMaterial();
        tslShaderMaterial.colorNode = crtTSLFn();


				camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				scene = new THREE.Scene();

				const geometry = new THREE.PlaneGeometry( 2, 1 );

				const wgslQuad = new THREE.Mesh( geometry, wgslShaderMaterial );
        wgslQuad.position.y += 0.5;
				scene.add( wgslQuad );

        const tslQuad = new THREE.Mesh(geometry, tslShaderMaterial);
        tslQuad.position.y -= 0.5;
        scene.add(tslQuad);

				//

				renderer = new WebGPURenderer( { antialias: true} );
				renderer.setPixelRatio( dpr );
				renderer.setSize( window.innerWidth, window.innerHeight);
				renderer.setAnimationLoop( animate );
				renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

        const gui = new GUI();

				gui.add( cellSizeUniform, 'value', 6, 50, 1 ).name( 'cellSize' );
				gui.add( cellOffsetUniform, 'value', 0, 1, 0.1 ).name( 'cellOffset' );
				gui.add( borderMaskUniform, 'value', 0, 5, 0.1 ).name( 'borderMask' );

			}

      init();

		</script>
	</body>
</html>
