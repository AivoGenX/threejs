<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interleavedbuffergeometry</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #fff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #050505;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #ff00ff;
			}

			#stats { position: absolute; top:0; left: 0 }
			#stats #fps { background: transparent !important }
			#stats #fps #fpsText { color: #fff !important }
			#stats #fps #fpsGraph { display: none }

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - Interveaved Indexed Buffered Geometry<br />
            <span id="counts">(150,000 cubes - 1.8M triangles)</span><br />
            Based on <a href="http://alteredqualia.com/three/examples/webgl_cubes.html">AlteredQualia's 1.8M triangle Animated Cube demo</a>

		</div>

		<script src="../build/three.min.js"></script>

		<script src="../src/core/InterleavedBufferGeometry.js"></script>
		<script src="../src/renderers/WebGLRenderer.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
        <script src="js/libs/dat.gui.min.js"></script>

		<script type="x-shader/x-vertex" id="vertexShader">

			uniform float amplitude;

			varying vec3 vViewPosition;

			vec3 rotateVectorByQuaternion( vec3 v, vec4 q ) {

				vec3 dest = vec3( 0.0 );

				float x = v.x, y  = v.y, z  = v.z;
				float qx = q.x, qy = q.y, qz = q.z, qw = q.w;

				// calculate quaternion * vector

				float ix =  qw * x + qy * z - qz * y,
					  iy =  qw * y + qz * x - qx * z,
					  iz =  qw * z + qx * y - qy * x,
					  iw = -qx * x - qy * y - qz * z;

				// calculate result * inverse quaternion

				dest.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
				dest.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
				dest.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

				return dest;

			}

			vec4 axisAngleToQuaternion( vec3 axis, float angle ) {

				vec4 dest = vec4( 0.0 );

				float halfAngle = angle / 2.0,
					  s = sin( halfAngle );

				dest.x = axis.x * s;
				dest.y = axis.y * s;
				dest.z = axis.z * s;
				dest.w = cos( halfAngle );

				return dest;

			}

			void main() {

				vec4 rotation = vec4( 0.0, 1.0, 0.0, amplitude * length( color ) * 0.001 );
				vec4 qRotation = axisAngleToQuaternion( rotation.xyz, rotation.w );

				vec3 newPosition = rotateVectorByQuaternion( position - color, qRotation ) + color;

				vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );
				vViewPosition = -mvPosition.xyz;

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
            #extension GL_OES_standard_derivatives : enable

			varying vec3 vViewPosition;

			void main() {

				vec3 normal  = normalize(cross(dFdx(vViewPosition), dFdy(vViewPosition)));

				// directional light

				const vec3 lightCol1 = vec3( 0.5, 0.8, 1.0 );
				const vec3 lightDir1 = vec3( 0.0, -1.0, 0.0 );
				const float intensity1 = 0.5;

				vec4 lDirection1 = viewMatrix * vec4( lightDir1, 0.0 );
				vec3 lightVec1 = normalize( lDirection1.xyz );

				// point light

				const vec3 lightPos2 = vec3( 0.0, 0.0, 0.0 );
				const vec3 lightCol2 = vec3( 1.0, 0.5, 0.0 );
				const float maxDistance2 = 2000.0;
				const float intensity2 = 1.5;

				vec4 lPosition = viewMatrix * vec4( lightPos2, 1.0 );
				vec3 lVector = lPosition.xyz + vViewPosition.xyz;

				vec3 lightVec2 = normalize( lVector );
				float lDistance2 = 1.0 - min( ( length( lVector ) / maxDistance2 ), 1.0 );

				// point light

				const vec3 lightPos3 = vec3( 0.0, -1000.0, 1000.0 );
				const vec3 lightCol3 = vec3( 1.0, 0.1, 0.0 );
				const float maxDistance3 = 3000.0;
				const float intensity3 = 1.0;

				vec4 lPosition3 = viewMatrix * vec4( lightPos3, 1.0 );
				vec3 lVector3 = lPosition3.xyz + vViewPosition.xyz;

				vec3 lightVec3 = normalize( lVector3 );
				float lDistance3 = 1.0 - min( ( length( lVector3 ) / maxDistance3 ), 1.0 );

				//

				float diffuse1 = intensity1 * max( dot( normal, lightVec1 ), 0.0 );
				float diffuse2 = intensity2 * max( dot( normal, lightVec2 ), 0.0 ) * lDistance2;
				float diffuse3 = intensity2 * max( dot( normal, lightVec3 ), 0.0 ) * lDistance3;

				gl_FragColor = vec4( diffuse1 * lightCol1 + diffuse2 * lightCol2 + diffuse3 * lightCol3, 1.0 );

			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer;

			var mesh, text;

			var clock = new THREE.Clock();

			function init() {

			    function GenerateGeometry() {

			        var cubes = text['Cube Count'];
			        var triangles = 12 * cubes; // 12 triangles per cube (6 quads)

			        // BufferGeometry with indexed triangles
			        // use vertex colors to store centers of rotations

			        var geometry = new THREE.InterleavedBufferGeometry();

			        geometry.numVertices = cubes * 8; //  Only 8 vertexes need to be defined per cube
			        geometry.attributes = {

			            index: {
			                itemSize: 1,
			                array: new Uint16Array(triangles * 3),
			                numItems: triangles * 3
			            },

			            position: {
			                itemSize: 3,
			                numItems: geometry.numVertices * 3,
			                offset: 0,
			                array: null
			            },

			            color: {
			                itemSize: 3,
			                numItems: geometry.numVertices * 3,
			                offset: 3 * Float32Array.BYTES_PER_ELEMENT,
			                array: null
			            }

			        }

			        geometry.vertexByteSize
                        = geometry.attributes.position.itemSize * Float32Array.BYTES_PER_ELEMENT
                        + geometry.attributes.color.itemSize * Float32Array.BYTES_PER_ELEMENT;

			        geometry.array = new ArrayBuffer(geometry.numVertices * geometry.vertexByteSize);

			        geometry.attributes.position.array = new Float32Array(geometry.array, geometry.attributes.position.offset);
			        geometry.attributes.color.array = new Float32Array(geometry.array, geometry.attributes.color.offset);

			        var positions = geometry.attributes.position.array;
			        var colors = geometry.attributes.color.array;

			        var indices = geometry.attributes.index.array;

			        // Generate a single buffer with all the cubes

			        var n = 8000, n2 = n / 2;	// triangles spread in the cube
			        var d = 10, d2 = d / 2;	// individual triangle size

			        //

			        var color = new THREE.Color();

			        var pA = new THREE.Vector3();

			        var cb = new THREE.Vector3();
			        var ab = new THREE.Vector3();

			        var m = new THREE.Matrix4();
			        var m2 = new THREE.Matrix4();

			        var e = new THREE.Vector3(0, 0, 0);
			        var t = new THREE.Vector3();
			        var tt = new THREE.Vector3();
			        var u = new THREE.Vector3(0, 1, 0);

			        var v1 = new THREE.Vector3(0, 0, 0);
			        var v2 = new THREE.Vector3(d, 0, 0);
			        var v3 = new THREE.Vector3(d, d, 0);
			        var v4 = new THREE.Vector3(0, d, 0);

			        var v1b = new THREE.Vector3(0, 0, d);
			        var v2b = new THREE.Vector3(d, 0, d);
			        var v3b = new THREE.Vector3(d, d, d);
			        var v4b = new THREE.Vector3(0, d, d);

			        //

			        function addVertex(k, x, y, z, va) {

			            // positions

			            pA.copy(va);

			            t.set(x, y, z);
			            t.multiplyScalar(0.5);

			            m.lookAt(e, tt, u);

			            m2.makeTranslation(t.x, t.y, t.z);

			            m2.multiply(m);

			            pA.applyMatrix4(m2);

			            var j = k * 6;

			            positions[j] = pA.x;
			            positions[j + 1] = pA.y;
			            positions[j + 2] = pA.z;

			            // colors

			            color.setRGB(t.x, t.y, t.z);

			            colors[j] = color.r;
			            colors[j + 1] = color.g;
			            colors[j + 2] = color.b;

			        }

			        var chunkSize = 65536;

			        //
			        var v = -1; // easier to number vertices from previous example
			        for (var i = 0; i < indices.length; i += 36) {

			            //

			            indices[i] = v + 1 % chunkSize;
			            indices[i + 1] = v + 2 % chunkSize;
			            indices[i + 2] = v + 4 % chunkSize;

			            indices[i + 3] = v + 2 % chunkSize;
			            indices[i + 4] = v + 3 % chunkSize;
			            indices[i + 5] = v + 4 % chunkSize;


			            indices[i + 6] = v + 8 % chunkSize;
			            indices[i + 7] = v + 6 % chunkSize;
			            indices[i + 8] = v + 5 % chunkSize;

			            indices[i + 9] = v + 8 % chunkSize;
			            indices[i + 10] = v + 7 % chunkSize;
			            indices[i + 11] = v + 6 % chunkSize;

			            //

			            indices[i + 12] = v + 5 % chunkSize;
			            indices[i + 13] = v + 2 % chunkSize;
			            indices[i + 14] = v + 1 % chunkSize;

			            indices[i + 15] = v + 5 % chunkSize;
			            indices[i + 16] = v + 6 % chunkSize;
			            indices[i + 17] = v + 2 % chunkSize;


			            indices[i + 18] = v + 6 % chunkSize;
			            indices[i + 19] = v + 3 % chunkSize;
			            indices[i + 20] = v + 2 % chunkSize;

			            indices[i + 21] = v + 6 % chunkSize;
			            indices[i + 22] = v + 7 % chunkSize;
			            indices[i + 23] = v + 3 % chunkSize;

			            //

			            indices[i + 24] = v + 7 % chunkSize;
			            indices[i + 25] = v + 4 % chunkSize;
			            indices[i + 26] = v + 3 % chunkSize;

			            indices[i + 27] = v + 7 % chunkSize;
			            indices[i + 28] = v + 8 % chunkSize;
			            indices[i + 29] = v + 4 % chunkSize;


			            indices[i + 30] = v + 1 % chunkSize;
			            indices[i + 31] = v + 4 % chunkSize;
			            indices[i + 32] = v + 5 % chunkSize;

			            indices[i + 33] = v + 4 % chunkSize;
			            indices[i + 34] = v + 8 % chunkSize;
			            indices[i + 35] = v + 5 % chunkSize;

			            v += 8;
			        }

			        for (var i = 0; i < geometry.numVertices; i += 8) {

			            var x = THREE.Math.randFloat(0.1 * n, 0.2 * n) * (Math.random() > 0.5 ? 1 : -1) * THREE.Math.randInt(0.5, 2);
			            var y = THREE.Math.randFloat(0.1 * n, 0.2 * n) * (Math.random() > 0.5 ? 1 : -1) * THREE.Math.randInt(0.5, 2);
			            var z = THREE.Math.randFloat(0.1 * n, 0.2 * n) * (Math.random() > 0.5 ? 1 : -1) * THREE.Math.randInt(0.5, 2);

			            tt.set(Math.random(), Math.random(), Math.random());

			            //
			            addVertex(i, x, y, z, v1);
			            addVertex(i + 1, x, y, z, v2);
			            addVertex(i + 2, x, y, z, v3);
			            addVertex(i + 3, x, y, z, v4);


			            addVertex(i + 4, x, y, z, v1b);
			            addVertex(i + 5, x, y, z, v2b);
			            addVertex(i + 6, x, y, z, v3b);
			            addVertex(i + 7, x, y, z, v4b);

			        }

			        geometry.offsets = [];

			        // break geometry into
			        // chunks
			        // for indices to fit into 16 bit integer number
			        // floor(2^16 / 3) = 21845

			        var offsets = geometry.numVertices / chunkSize;

			        for (var i = 0; i < offsets; i++) {

			            var offset = {
			                start: i * chunkSize * (12 / 8) * 3,
			                index: i * chunkSize,
			                count: Math.min(triangles - (i * chunkSize * (12 / 8)), chunkSize * (12 / 8)) * 3
			            };

			            geometry.offsets.push(offset);

			        }

			        geometry.computeBoundingSphere();

			        mesh = new THREE.Mesh(geometry, material);
			        scene.add(mesh);

			    }

			    //
			    var UIText = function () {
			        this['Cube Count'] = 150000;
			        // Define render logic ...
			    };

			    var text = new UIText();

			    var gui = new dat.GUI();
			    var controller = gui.add(text, 'Cube Count', { '600k Cubes (7.2M tri)': 600000, '300k Cubes (3.6M tri)': 300000, '150k Cubes (1.8M tri)': 150000, '75k Cubes (900k tri)': 75000, '30k Cubes (360k tri)': 30000, '15k Cubes (180k tri)': 15000 });
			    controller.onChange(function (value) {

			        scene.remove(mesh);

			        mesh.geometry.dispose();

			        switch (value|0) {
			            case 600000:
			                document.getElementById("counts").innerHTML = '(600,000 cubes - 7.2M triangles)';
			                break;
			            case 300000:
                            document.getElementById("counts").innerHTML = '(300,000 cubes - 3.6M triangles)';
                            break;
			            case 150000:
                            document.getElementById("counts").innerHTML = '(150,000 cubes - 1.8M triangles)';
                            break;
			            case 75000:
                            document.getElementById("counts").innerHTML = '(75,000 cubes - 900k triangles)';
                            break;
			            case 30000:
                            document.getElementById("counts").innerHTML = '(30,000 cubes - 360k triangles)';
                            break;
			            case 15000:
                            document.getElementById("counts").innerHTML = '(15,000 cubes - 180k triangles)';
                            break;

			        }
                    
			        GenerateGeometry();

			    });


				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 37, window.innerWidth / window.innerHeight, 1, 8000 );
				camera.position.z = 2750;
				camera.position.y = 1250;

				scene = new THREE.Scene();

				camera.lookAt( scene.position );

			    // Set up custom shader material

			    uniforms = {

			        amplitude: { type: "f", value: 0.0 }

			    };

			    var material = new THREE.ShaderMaterial({

			        uniforms: uniforms,
			        vertexShader: document.getElementById('vertexShader').textContent,
			        fragmentShader: document.getElementById('fragmentShader').textContent,
			        vertexColors: THREE.VertexColors

			    });

			    //

			    GenerateGeometry();

				//

				renderer = new THREE.WebGLRenderer( { antialias: false, alpha: false, stencil: false } );
				renderer.setSize( window.innerWidth, window.innerHeight );
                
				renderer.setClearColor(0x050505);
				container.appendChild( renderer.domElement );

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );


			    // Remove unneeded plugins

				renderer.renderPluginsPre = [];
				renderer.renderPluginsPost = [];

                //

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var time = Date.now() * 0.001;
				var delta = clock.getDelta();

				mesh.rotation.x = time * 0.025;
				mesh.rotation.y = time * 0.05;

				uniforms.amplitude.value += 2 * delta;

				renderer.render( scene, camera );

			}

			init();
			animate();

		</script>

	</body>
</html>
