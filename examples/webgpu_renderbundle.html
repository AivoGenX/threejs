<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgpu - renderbundle</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		#info {
			background-color: rgba(0,0,0,0.75);
		}
	</style>
</head>
<body>

	<div id="info">

		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - renderbundle

	</div>

	<div id="backend" style="position: absolute; top: 200px; left: 0; color: #fff; background-color: rgba(0,0,0,0.75); padding: 5px;">
		Draw Calls: 0
	</div>

	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js",
				"three/addons/": "./jsm/",
				"three/nodes": "./jsm/nodes/Nodes.js",
				"stats-gl": "https://cdn.jsdelivr.net/npm/stats-gl@2.2.7/dist/main.js"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';

		import Stats from 'stats-gl';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
		import RenderBundle from 'three/addons/renderers/RenderBundle.js';
		import { MeshBasicNodeMaterial } from 'three/nodes';

		let camera, scene, renderer, renderBundle;
		let controls, stats;
		let gui;
		let geometries, group;

		let renderTimeAverages = [];
		//

		const position = new THREE.Vector3();
		const rotation = new THREE.Euler();
		const quaternion = new THREE.Quaternion();
		const scale = new THREE.Vector3();

		//

		const MAX_GEOMETRY_COUNT = 4000;

		const api = {
			webgpu: true,
			renderBundle: true,
			count: MAX_GEOMETRY_COUNT,
			dynamic: MAX_GEOMETRY_COUNT / 2,
			opacity: 1,
		};


		init( ! api.webgpu );

		//

		function randomizeMatrix( matrix ) {

			position.x = Math.random() * 80 - 40;
			position.y = Math.random() * 80 - 40;
			position.z = Math.random() * 80 - 40;

			rotation.x = Math.random() * 2 * Math.PI;
			rotation.y = Math.random() * 2 * Math.PI;
			rotation.z = Math.random() * 2 * Math.PI;

			quaternion.setFromEuler( rotation );

			scale.x = scale.y = scale.z = 0.35 + ( Math.random() * 0.5 );

			return matrix.compose( position, quaternion, scale );

		}

		function randomizeRotationSpeed( rotation ) {

			rotation.x = Math.random() * .05;
			rotation.y = Math.random() * .05;
			rotation.z = Math.random() * .05;
			return rotation;

		}

		function initGeometries() {

			geometries = [
				new THREE.ConeGeometry( 1.0, 2.0, 3, 1 ),
				// new THREE.BoxGeometry( 2.0, 2.0, 2.0 ),
				// new THREE.PlaneGeometry( 2., 2, 1, 1 ),
			];

		}




		function cleanup() {

			if ( group ) {

				group.parent.remove( group );

				if ( group.dispose ) {

					group.dispose();

				}

			}

		}

		function initMesh() {

			cleanup();
			initRegularMesh();

		}


		function initRegularMesh() {

			group = new THREE.Group();

			for ( let i = 0; i < api.count; i ++ ) {

				// const material = new THREE.MeshPhysicalMaterial( {
				// 	color: new THREE.Color( Math.random() * 0xffffff ),
				// 	roughness: Math.random(),
				// 	metalness: Math.random(),
				// 	clearcoatRoughness: Math.random(),
				// 	reflectivity: Math.random(),
				// 	specularIntensity: Math.random(),
				// } );
				const material = new MeshBasicNodeMaterial( {
					color: new THREE.Color( Math.random() * 0xffffff ),
					side: THREE.DoubleSide,
				} );

				const child = new THREE.Mesh( geometries[ i % geometries.length ], material );
				randomizeMatrix( child.matrix );
				child.matrix.decompose( child.position, child.quaternion, child.scale );
				child.userData.rotationSpeed = randomizeRotationSpeed( new THREE.Euler() );
				child.frustumCulled = false;
				// child.matrixAutoUpdate = false;
				group.add( child );

			}

			scene.add( group );

		}

		async function init( forceWebGL = false ) {

			renderTimeAverages = [];

			if ( renderer ) {

				renderer.dispose();
				controls.dispose();
				document.body.removeChild( stats.dom );
				document.body.removeChild( renderer.domElement );

			}

			// camera

			const aspect = window.innerWidth / window.innerHeight;

			camera = new THREE.PerspectiveCamera( 70, aspect, 1, 100 );
			camera.position.z = 50;

			// renderer

			renderer = new WebGPURenderer( { antialias: true, forceWebGL } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );

			renderer.setAnimationLoop( animate );

			// scene

			scene = new THREE.Scene();


			if ( forceWebGL ) {

				scene.background = new THREE.Color( 0xf10000 );

			} else {

				scene.background = new THREE.Color( 0x330000 );

			}

			const light = new THREE.DirectionalLight( 0xffffff, 2.4 );
			scene.add( light );

			document.body.appendChild( renderer.domElement );

			await renderer.init();
			// renderer.render( scene, camera );


			initGeometries();
			initMesh();


			if ( api.renderBundle ) {

				renderBundle = new RenderBundle( scene, camera );

			}


			controls = new OrbitControls( camera, renderer.domElement );
			controls.autoRotate = true;
			controls.autoRotateSpeed = 1.0;

			// stats

			stats = new Stats( {
				precision: 3,
				horizontal: false
			} );
			// stats.init( renderer );
			document.body.appendChild( stats.dom );
			stats.dom.style.position = 'absolute';

			// gui

			gui = new GUI();
			gui.add( api, 'renderBundle' ).onChange( () => {

				init( ! api.webgpu );

			} );

			gui.add( api, 'webgpu' ).onChange( () => {

				init( ! api.webgpu );

			} );

			gui.add( api, 'count', 1, MAX_GEOMETRY_COUNT ).step( 1 ).onChange( initMesh );
			gui.add( api, 'dynamic', 0, MAX_GEOMETRY_COUNT ).step( 1 );

			// listeners

			window.addEventListener( 'resize', onWindowResize );




			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
		
			}


			async function animate() {

				animateMeshes();

				controls.update();

				const renderTimeAverage = performance.now();
				if ( api.renderBundle ) {
		
					renderer.renderBundle( renderBundle );

				} else {

					renderer.render( scene, camera );
		
				}

				// push only the last 60 render times
				renderTimeAverages.push( performance.now() - renderTimeAverage );
				if ( renderTimeAverages.length > 60 ) renderTimeAverages.shift();
		
				const average = renderTimeAverages.reduce( ( a, b ) => a + b, 0 ) / renderTimeAverages.length;
				stats.update();

				document.getElementById( 'backend' ).innerText = `Average Render Time ${api.renderBundle ? '(Bundle)' : ''}: ` + average.toFixed( 2 ) + 'ms';

			}

			function animateMeshes() {

				const loopNum = Math.min( api.count, api.dynamic );


				for ( let i = 0; i < loopNum; i ++ ) {

					const child = group.children[ i ];
					const rotationSpeed = child.userData.rotationSpeed;

					child.rotation.set(
						child.rotation.x + rotationSpeed.x,
						child.rotation.y + rotationSpeed.y,
						child.rotation.z + rotationSpeed.z
					);

				}

			}

}
	</script>

</body>
</html>
