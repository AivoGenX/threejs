<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl2 - volume - cloud</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl2 - volume - cloud
		</div>

		<script type="module">
			import * as THREE from '../build/three.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { ImprovedNoise } from './jsm/math/ImprovedNoise.js';
			import { FullScreenQuad } from './jsm/postprocessing/Pass.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { WEBGL } from './jsm/WebGL.js';

			if ( WEBGL.isWebGL2Available() === false ) {

				document.body.appendChild( WEBGL.getWebGL2ErrorMessage() );

			}

			const _minusZ = new THREE.Vector3(0.0, 0.0, -1.0);

			const _vector2 = new THREE.Vector2();
			const _vector3 = new THREE.Vector3();
			const _pointA = new THREE.Vector3();
			const _pointB = new THREE.Vector3();

			const SHADOW_PASS_CLEAR_COLOR = new THREE.Color(0xFFFFFF);
			const INITIAL_CLOUD_SIZE = 128;

			const fragmentShadowing = `
				precision highp float;
				precision highp sampler3D;

				in vec2 vUv;
				out vec4 color;

				uniform sampler3D volume;
				uniform sampler3D shadowVolume;
				uniform vec3 			lightDirectionVolume;
				uniform float 		slice;

				vec4 attenuation(vec3 localPosition)
				{
					// @todo: use step size.
					vec4 prev = texture(shadowVolume, vec3(localPosition.xy, localPosition.z - 1.0));
					if (slice <= 0.00001) {
						prev = vec4(1.0);
					}
					return prev * 0.9;
				}

				void main()
				{
					vec3 localPosition = vec3(vUv, slice);
					color = attenuation(localPosition);

					// if (lightDirectionVolume.y < - 0.5) {
					// 	color = vec4(1.0, 0.0, 0.0, 1.0);
					// } else {
					// 	color = vec4(1.0);
					// }

					// if (slice > 0.0 && slice <= 1.0 / 128.0 + 0.000001)
					// {
					// 	color =	vec4(1.0, 0.0, 0.0, 0.0);
					// } else if (slice > 0.0 && slice <= 2.0 / 128.0 + 0.000001)
					// {
					// 	color =	vec4(0.0, 1.0, 0.0, 0.0);
					// }
					// else if (slice > 0.0 && slice <= 3.0 / 128.0 + 0.000001)
					// {
					// 	color =	vec4(0.0, 0.0, 0.0, 1.0);
					// }
					// else
					// {
					// 	color = vec4(1.0);
					// }
				}

			`;

			class ShadowVolume extends THREE.Object3D {

				constructor(volume) {

					super();

					this.texture = null;

					if (volume) {

						this._init(volume)

					}

				}

				render(light) {

					const direction = light.target.getWorldPosition(_pointA);
					direction
						.sub(light.target.getWorldPosition(_pointB))
						.normalize();

					this.quaternion.setFromUnitVectors(_minusZ, direction);
					this.updateMatrix();

				}

				_init(volume) {

					// Assumes the volume is a cube. For non-uniform volume, we need
					// to compute the appropriate x, y, z basis.
					// Diagonal of a cube: a * sqrt(3).
					//
					// This is a bit wasteful in terms of texture memory but it
					// avoids to re-upload the texture and is easier to manage for an example.
					const diagonal = volume.image.width * Math.sqrt(3);
					const texture = new THREE.DataTexture3D(null, diagonal, diagonal, diagonal);
					texture.format = THREE.RGBAFormat;
					texture.internalFormat = 'RGBA16F';
					texture.type = THREE.HalfFloatType;
					texture.unpackAlignment = 1;
					texture.minFilter = THREE.LinearFilter;
					texture.magFilter = THREE.LinearFilter;
					this.texture = texture;

				}

			}

			let renderer, scene, camera, light;
			let mesh;
			
			let shadowScene, shadowRenderTarget, shadowMaterial, shadowVolume;

			let prevTime = performance.now();

			init();
			animate();

			function generateCloudTexture( size, scaleFactor = 1.0 ) {

				const data = new Uint8Array( size * size * size );
				const scale = scaleFactor * 10.0 / size;

				let i = 0;
				const perlin = new ImprovedNoise();
				const vector = new THREE.Vector3();

				for ( let z = 0; z < size; z ++ ) {

					for ( let y = 0; y < size; y ++ ) {

						for ( let x = 0; x < size; x ++ ) {

							const dist = vector.set( x, y, z ).subScalar( size / 2 ).divideScalar( size ).length();
							const fadingFactor = ( 1.0 - dist ) * ( 1.0 - dist );
							data[ i ] = ( 128 + 128 * perlin.noise( x * scale / 1.5, y * scale, z * scale / 1.5 ) ) * fadingFactor;

							i ++;

						}

					}

				}

				return new THREE.DataTexture3D( data, size, size, size );

			}

			function init() {

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 0, 1.5 );

				new OrbitControls( camera, renderer.domElement );

				// Volume texture

				const texture = generateCloudTexture(INITIAL_CLOUD_SIZE);
				texture.format = THREE.RedFormat;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.unpackAlignment = 1;

				// Shadow Pass

				shadowVolume = new ShadowVolume(texture);

				shadowMaterial = new THREE.RawShaderMaterial( {
					glslVersion: THREE.GLSL3,
					uniforms: {
						volume: { value: texture },
						shadowVolume: { value: shadowVolume.texture },
						lightDirectionVolume: { value: new THREE.Vector3() },
						slice: { value: 0.0 }
					},
					vertexShader: `
						in vec3 position;
						in vec2 uv;
						out vec2 vUv;

						uniform mat4 projectionMatrix;
						void main() {
							vUv = uv;
							gl_Position = projectionMatrix * vec4( position, 1.0 );
						}`,
					fragmentShader: fragmentShadowing,
					side: THREE.FrontSide,
					transparent: false
				} );

				shadowScene = new FullScreenQuad(shadowMaterial);

				shadowRenderTarget = new THREE.WebGLRenderTarget( INITIAL_CLOUD_SIZE, INITIAL_CLOUD_SIZE, {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					// format: THREE.RedFormat,
					// internalFormat: 'R16F',
					format: THREE.RGBAFormat,
					internalFormat: 'RGBA16F',
					type: THREE.HalfFloatType,
					stencilBuffer: false,
					depthBuffer: false
				} );

				// Sky

				const canvas = document.createElement( 'canvas' );
				canvas.width = 1;
				canvas.height = 32;

				const context = canvas.getContext( '2d' );
				const gradient = context.createLinearGradient( 0, 0, 0, 32 );
				gradient.addColorStop( 0.0, '#014a84' );
				gradient.addColorStop( 0.5, '#0561a0' );
				gradient.addColorStop( 1.0, '#437ab6' );
				context.fillStyle = gradient;
				context.fillRect( 0, 0, 1, 32 );

				const sky = new THREE.Mesh(
					new THREE.SphereGeometry( 10 ),
					new THREE.MeshBasicMaterial( { map: new THREE.CanvasTexture( canvas ), side: THREE.BackSide } )
				);
				scene.add( sky );

				// Light

				light = new THREE.DirectionalLight();
				light.target.position.set(0.0, -1.0, 0.0);
				light.target.updateMatrix();

				// Material

				const vertexShader = /* glsl */`
					in vec3 position;

					uniform mat4 modelMatrix;
					uniform mat4 modelViewMatrix;
					uniform mat4 projectionMatrix;
					uniform vec3 cameraPos;

					out vec3 vOrigin;
					out vec3 vDirection;

					void main() {
						vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

						vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;
						vDirection = position - vOrigin;

						gl_Position = projectionMatrix * mvPosition;
					}
				`;

				const fragmentShader = /* glsl */`
					precision highp float;
					precision highp sampler3D;

					uniform mat4 modelViewMatrix;
					uniform mat4 projectionMatrix;
					uniform mat4 volumeToShadowVolume;

					in vec3 vOrigin;
					in vec3 vDirection;

					out vec4 color;

					uniform vec3 base;
					uniform sampler3D map;
					uniform sampler3D shadowTexture;

					uniform float threshold;
					uniform float range;
					uniform float opacity;
					uniform float steps;
					uniform float frame;

					#include <tonemapping_pars_fragment>

					uint wang_hash(uint seed)
					{
							seed = (seed ^ 61u) ^ (seed >> 16u);
							seed *= 9u;
							seed = seed ^ (seed >> 4u);
							seed *= 0x27d4eb2du;
							seed = seed ^ (seed >> 15u);
							return seed;
					}

					float randomFloat(inout uint seed)
					{
							return float(wang_hash(seed)) / 4294967296.;
					}

					vec2 hitBox( vec3 orig, vec3 dir ) {
						const vec3 box_min = vec3( - 0.5 );
						const vec3 box_max = vec3( 0.5 );
						vec3 inv_dir = 1.0 / dir;
						vec3 tmin_tmp = ( box_min - orig ) * inv_dir;
						vec3 tmax_tmp = ( box_max - orig ) * inv_dir;
						vec3 tmin = min( tmin_tmp, tmax_tmp );
						vec3 tmax = max( tmin_tmp, tmax_tmp );
						float t0 = max( tmin.x, max( tmin.y, tmin.z ) );
						float t1 = min( tmax.x, min( tmax.y, tmax.z ) );
						return vec2( t0, t1 );
					}

					float sample1( vec3 p ) {
						return texture( map, p ).r;
					}

					vec3 sampleShadow( vec3 p )
					{
						return texture( shadowTexture, p + 0.5 ).rgb;
					}

					vec3
					computeGradient(vec3 position, float step)
					{
						return normalize(vec3(
							sample1(vec3(position.x + step, position.y, position.z))
							- sample1(vec3(position.x - step, position.y, position.z)),
							sample1(vec3(position.x, position.y + step, position.z))
							- sample1(vec3(position.x, position.y - step, position.z)),
							sample1(vec3(position.x, position.y, position.z + step))
							- sample1(vec3(position.x, position.y, position.z - step))
						));
					}

					float shading( vec3 coord ) {
						float step = 0.01;
						vec3 gradient = computeGradient(coord, step);
						float ambient = 0.075;
						return dot(gradient, vec3(1.0, 0.0, 0.0)) + ambient;
						// return dot(gradient, vec3(1.0, 0.0, 0.0)) * (sample1( coord + vec3( - step ) ) - sample1( coord + vec3( step ) ));
						// return sample1( coord + vec3( - step ) ) - sample1( coord + vec3( step ) );
					}

					vec3 localShading(vec3 pos)
					{
						float step = 0.01;
						vec3 gradient = computeGradient(pos, step);

						vec3 diffuseColor = vec3(0.8);
						vec3 ambient = vec3(0.075);
						vec3 diffuse = diffuseColor * dot(gradient, vec3(1.0, 0.0, 0.0));

						return diffuse + ambient;
					}

					void main(){
						vec3 rayDir = normalize( vDirection );
						vec2 bounds = hitBox( vOrigin, rayDir );

						if ( bounds.x > bounds.y ) discard;

						bounds.x = max( bounds.x, 0.0 );

						vec3 p = vOrigin + bounds.x * rayDir;
						vec3 inc = 1.0 / abs( rayDir );
						float delta = min( inc.x, min( inc.y, inc.z ) );
						delta /= steps;

						// Jitter

						// Nice little seed from
						// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/
						uint seed = uint( gl_FragCoord.x ) * uint( 1973 ) + uint( gl_FragCoord.y ) * uint( 9277 ) + uint( frame ) * uint( 26699 );
						vec3 size = vec3( textureSize( map, 0 ) );
						float randNum = randomFloat( seed ) * 2.0 - 1.0;
						p += rayDir * randNum * ( 1.0 / size );

						//

						vec4 ac = vec4( base, 0.0 );

						for ( float t = bounds.x; t < bounds.y; t += delta ) {

							float d = sample1( p + 0.5 );

							d = smoothstep( threshold - range, threshold + range, d ) * opacity;

							vec3 col = vec3(1.0) * sampleShadow( p );

							ac.rgb += ( 1.0 - ac.a ) * d * col;

							ac.a += ( 1.0 - ac.a ) * d;

							if ( ac.a >= 0.95 ) break;

							p += rayDir * delta;

						}

						ac.rgb = ACESFilmicToneMapping(ac.rgb);
						color = ac;

						if ( color.a == 0.0 ) discard;

					}
				`;

				const geometry = new THREE.BoxGeometry( 1, 1, 1 );
				const material = new THREE.RawShaderMaterial( {
					glslVersion: THREE.GLSL3,
					uniforms: {
						// base: { value: new THREE.Color( 0x798aa0 ) },
						base: { value: new THREE.Color( 0x111111 ) },
						map: { value: texture },
						shadowTexture: { value: shadowVolume.texture },
						cameraPos: { value: new THREE.Vector3() },
						threshold: { value: 0.25 },
						opacity: { value: 0.25 },
						range: { value: 0.1 },
						steps: { value: 100 },
						frame: { value: 0 }
					},
					vertexShader,
					fragmentShader,
					side: THREE.BackSide,
					transparent: true
				} );

				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				//

				const parameters = {
					threshold: 0.25,
					opacity: 0.25,
					range: 0.1,
					steps: 100
				};

				function update() {

					material.uniforms.threshold.value = parameters.threshold;
					material.uniforms.opacity.value = parameters.opacity;
					material.uniforms.range.value = parameters.range;
					material.uniforms.steps.value = parameters.steps;

				}

				const gui = new GUI();
				gui.add( parameters, 'threshold', 0, 1, 0.01 ).onChange( update );
				gui.add( parameters, 'opacity', 0, 1, 0.01 ).onChange( update );
				gui.add( parameters, 'range', 0, 1, 0.01 ).onChange( update );
				gui.add( parameters, 'steps', 0, 200, 1 ).onChange( update );

				window.addEventListener( 'resize', onWindowResize );

			}

			function updateShadow() {
				const light = new THREE.Vector3(0.0, -1.0, 0.0);

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				// mesh.rotation.y = - performance.now() / 7500;
				mesh.updateMatrixWorld();

				/** Step 1: Renders shadow volume first. */

				// Update light.

				const m = new THREE.Matrix4();
				m.copy(mesh.matrixWorld).invert();
				shadowMaterial.uniforms.lightDirectionVolume.value.set(0.0, -1.0, 0.0);
				shadowMaterial.uniforms.lightDirectionVolume.value.applyMatrix4(m);

				renderer.setRenderTarget( shadowRenderTarget );
				renderer.autoClear = false;
				renderer.setClearColor(SHADOW_PASS_CLEAR_COLOR, 1.0);
				renderer.clearColor();
				for (let i = 0; i < INITIAL_CLOUD_SIZE; ++i) {
					shadowMaterial.uniforms.slice.value = i / INITIAL_CLOUD_SIZE;
					shadowScene.render(renderer);

					// Copies slice from framebuffer into 3D texture.
					const srcPos = _vector2.set(0, 0);
					const dstPos = _vector3.set(0, 0, i);
					renderer.copyFramebufferToTexture3D(srcPos, dstPos, shadowVolume.texture);
				}

				renderer.autoClear = true;
				renderer.setRenderTarget( null );

				// Renders volume and uses shadow texture.
			
				mesh.material.uniforms.cameraPos.value.copy( camera.position );
				mesh.material.uniforms.frame.value ++;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
