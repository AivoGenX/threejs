<html lang="en">
	<head>
		<title>three.js - Nodes - GPGPU</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> Nodes - GPGPU
		</div>

		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { ShaderNode, color, remainder, add, sub, mul, uint, bitXor, shiftRight, vec4, uvec4 } from 'three/nodes';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

			import WebGLComputationRenderer from 'three/addons/gpgpu/WebGLComputationRenderer.js';
			import WebGPUComputationRenderer from 'three/addons/gpgpu/WebGPUComputationRenderer.js';

			import { getTextureType, getTextureFormat, calculateWidthHeight } from 'three/addons/gpgpu/WebGLTypedBuffer.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const params = {

				renderer: 'WebGL',
				example: 'Multiplication',
				reuploadOutput: true,
				warmUps: 2,
				logBuffers: false,
				logPerformance: true,
				refresh: false

			};

			const hash = new ShaderNode( ( { num }, builder ) => { // Taken from pcg-random.org

				const state = add( mul( uint( num ), 747796405 ), 2891336453 );
				const word = mul( bitXor( shiftRight( state, add( shiftRight( state, 28 ), 4 ) ), state ), 277803737 );
				const uintResult = bitXor( shiftRight( word, 22 ), word );

				return mul( 1 / 2 ** 32, uintResult ); // Convert to range [0, 1)

			} );

			let camera, scene, material, renderer, computationRenderer, iterations;

			const examples = [ 'Passthrough', 'AntiPassthrough', 'PassthroughColor', 'ElementManipulation', 'Multiplication', 'Random' ];

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 0, 2 );

				scene = new THREE.Scene();

				material = new THREE.MeshBasicMaterial();
				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( mesh );

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = new GUI();

				gui.add( params, 'renderer', [ 'WebGL', 'WebGPU' ] ).onChange( () => { setRenderer().then( showExample ); } );
				gui.add( params, 'example', examples ).onChange( showExample );
				gui.add( params, 'reuploadOutput' ).onChange( showExample );
				gui.add( params, 'warmUps', 0, 5, 1 ).onChange( () => { console.clear(); setRenderer().then( showExample ); } );
				gui.add( params, 'logBuffers' );
				gui.add( params, 'logPerformance' );
				gui.add( params, 'refresh' ).onChange( () => { params.refresh = false; setRenderer().then( showExample ); } );

				setRenderer();
				showExample();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function disposeRenderer( renderer ) {

				if ( material.map !== null ) {

					material.map.dispose(); // Texture should be disposed before disposing the renderer
					material.map = null;

				}

				if ( renderer !== undefined ) {

					renderer.domElement.remove();
					renderer.dispose();

				}

			}

			async function setRenderer() {

				const oldRenderer = renderer;

				document.getElementById( 'webgpumessage' )?.remove();

				if ( params.renderer === 'WebGPU' && WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					disposeRenderer( oldRenderer );

					throw new Error( 'No WebGPU support' );

				}

				if ( params.renderer === 'WebGL' ) {

					renderer = new THREE.WebGLRenderer();
					computationRenderer = new WebGLComputationRenderer();

				} else {

					renderer = new WebGPURenderer();
					await renderer.init();
					computationRenderer = new WebGPUComputationRenderer();

				}

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				disposeRenderer( oldRenderer );

				iterations = {};
				for ( let example of examples ) iterations[ example ] = 0;

			}

			async function showExample() {

				const iteration = iterations[ params.example ];
				iterations[ params.example ] ++;

				if ( params.logPerformance ) console.time( params.renderer + ' ' + params.example + ' Iteration-' + iteration );

				if ( material.map !== null ) {

					material.map.dispose();
					material.map = null;

				}

				let shaderNode, srcBuffer, outBuffer;

				const TypedArray = params.renderer === 'WebGL' ? Uint8Array : Uint32Array; // WebGPU can only work with uint32

				switch ( params.example ) {

					case 'Passthrough':
						shaderNode = new ShaderNode( ( { index }, builder ) => index );
						srcBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						outBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						break;

					case 'AntiPassthrough':
						shaderNode = new ShaderNode( ( { index }, builder ) => sub( 255, index ) );
						srcBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						outBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						break;

					case 'PassthroughColor':
						shaderNode = new ShaderNode( ( { index }, builder ) => params.renderer === 'WebGL' ? index : uvec4( index, index, index, uint( 255 ) ) );
						srcBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						outBuffer = computationRenderer.createBuffer( new TypedArray( 256 * 4 ), 4 );
						break;

					case 'ElementManipulation':
						shaderNode = new ShaderNode( ( { index, element }, builder ) => add( index, element ) );
						srcBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						srcBuffer.typedArray[ 0 ] = 255;
						srcBuffer.typedArray[ 7 ] = 192 - 7;
						srcBuffer.typedArray[ 8 ] = 64 - 8;
						srcBuffer.typedArray[ 15 ] = 255 - 15;
						srcBuffer.needsUpdate = true;
						outBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						break;

					case 'Multiplication':
						shaderNode = new ShaderNode( ( { index }, builder ) => {
							const result = [ remainder( mul( index, 2 ), 256 ), remainder( mul( index, 3 ), 256 ), remainder( mul( index, 5 ), 256 ) ];
							return params.renderer === 'WebGL' ? color( ...result ) : uvec4( ...result, uint( 255 ) );
						} );
						srcBuffer = computationRenderer.createBuffer( new TypedArray( 256 ) );
						outBuffer = computationRenderer.createBuffer( new TypedArray( 256 * 4 ), 4 );
						break;

					case 'Random':
						shaderNode = new ShaderNode( ( { index }, builder ) => {

							const r = hash.call( { num: add( mul( index, 4 ), 0 ) }, builder ); // @TODO: Tweak parameters to some that produce a more random image
							const g = hash.call( { num: add( mul( index, 4 ), 1 ) }, builder );
							const b = hash.call( { num: add( mul( index, 4 ), 2 ) }, builder );
							const a = hash.call( { num: add( mul( index, 4 ), 3 ) }, builder ); // Works only in WebGPU

							return mul( vec4( r, g, b, a ), vec4( 256, 256, 256, 256 ) );

						} );
						srcBuffer = computationRenderer.createBuffer( new TypedArray( 1024 ** 2 ) );
						outBuffer = computationRenderer.createBuffer( new TypedArray( 1024 ** 2 * 4 ), 4 );
						break;

				}

				computationRenderer.shaderNode = shaderNode;
				computationRenderer.setBuffers( srcBuffer, outBuffer );
				await computationRenderer.compute( renderer, params.reuploadOutput );

				const { typedArray, buffer } = outBuffer;
				if ( params.logBuffers && iteration === 0 ) console.log( params.renderer, params.example, typedArray );

				if ( params.renderer === 'WebGL' ) {

					if ( params.reuploadOutput === true ) {

						material.map = new THREE.DataTexture( typedArray, buffer.image.width, buffer.image.height, buffer.format, buffer.type );
						material.map.needsUpdate = true;

					} else {

						material.map = buffer;

					}

				} else {

					if ( params.reuploadOutput === true ) {

						const uint8TypedArray = uint32ToUint8( typedArray ); // WebGPU can only work with uint8 textures
						const type = getTextureType( uint8TypedArray );
						const format = getTextureFormat( outBuffer.elementSize );
						const { width, height } = calculateWidthHeight( outBuffer.length );
						material.map = new THREE.DataTexture( uint8TypedArray, width, height, format, type );
						material.map.needsUpdate = true;

					} else {

						// @TODO: Investigate how params.reuploadOutput === false can work with WebGPU renderer (can WebGPU storage buffer be used to populate a texture?)

					}

				}

				await renderer.render( scene, camera );

				srcBuffer.dispose();
				outBuffer.dispose();

				if ( params.logPerformance ) console.timeEnd( params.renderer + ' ' + params.example + ' Iteration-' + iteration );

				if ( iteration < params.warmUps ) await showExample();

			}

			function uint32ToUint8( uint32Array ) {

				const uint8Array = new Uint8Array( uint32Array.length );
				uint32Array.forEach( ( value, index ) => { uint8Array[ index ] = value; } );
				return uint8Array;

			}

		</script>
	</body>
</html>
