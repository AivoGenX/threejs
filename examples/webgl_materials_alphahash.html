<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js WebGL  - materials - alpha hash</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #505050;
				color: #f0f0f0;
			}

			a {
				color: #08f;
			}

			#container {
				position: absolute;
				width: 100%;
				top: 0;
				bottom: 0;
			}
		</style>
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - materials - alpha hash<br />
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			import { GUI } from './jsm/libs/lil-gui.module.min.js';

			import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './jsm/postprocessing/RenderPass.js';
			import { TAARenderPass } from './jsm/postprocessing/TAARenderPass.js';
			import { OutputPass } from './jsm/postprocessing/OutputPass.js';

			let camera, scene, renderer, group;

			let composer, renderTarget, renderPass, taaRenderPass, outputPass;

			let needsUpdate = false;

			const params = {
				alpha: 0.4,
				alphaHash: true,
				alphaHashScale: 0.1,
				taa: true,
				sampleLevel: 2,
			};

			init();
			animate();

			function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 100 );
				camera.position.set( 6, 1.5, 10 );
				camera.lookAt( scene.position );

				//

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 1, 0 );
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
				dirLight.position.set( - 3, 1, - 1 );
				scene.add( dirLight );

				//

				group = new THREE.Group();

				new GLTFLoader().load( 'models/gltf/chloroplast.glb', function ( gltf ) {

					group.add( gltf.scene );

					onMaterialUpdate();

				} );

				scene.add( group );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				renderPass = new RenderPass( scene, camera );
				renderPass.enabled = false;

				taaRenderPass = new TAARenderPass( scene, camera );
				taaRenderPass.params = { type: THREE.HalfFloatType };

				outputPass = new OutputPass();

				//

				const size = renderer.getDrawingBufferSize( new THREE.Vector2() );
				renderTarget = new THREE.WebGLRenderTarget( size.width, size.height, { type: THREE.HalfFloatType } );

				//

				composer = new EffectComposer( renderer, renderTarget );

				composer.addPass( renderPass );
				composer.addPass( taaRenderPass );
				composer.addPass( outputPass );

				//

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', () => ( needsUpdate = true ) );
				controls.minDistance = 5;
				controls.maxDistance = 15;
				controls.update();

				//

				const gui = new GUI();

				gui.add( params, 'alpha', 0, 1 ).onChange( onMaterialUpdate );
				gui.add( params, 'alphaHash' ).onChange( onMaterialUpdate );
				gui.add( params, 'alphaHashScale', 0.0, 2.0 ).onChange( onMaterialUpdate );

				const taaFolder = gui.addFolder('Temporal Anti-Aliasing');

				let sampleLevelCtrl;

				taaFolder.add( params, 'taa').name( 'enabled' ).onChange( () => {

					renderPass.enabled = ! params.taa;
					taaRenderPass.enabled = params.taa;

					sampleLevelCtrl.enable( params.taa );

					needsUpdate = true;

				} );

				sampleLevelCtrl = taaFolder.add( params, 'sampleLevel', 0, 6, 1 ).onChange( () => ( needsUpdate = true ) );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( window.innerWidth, window.innerHeight );

				needsUpdate = true;

			}

			function onMaterialUpdate() {

				scene.traverse( ( object ) => {

					if ( object.isMesh ) {

						object.material.opacity = params.alpha;
						object.material.alphaHash = params.alphaHash;
						object.material.alphaHashScale = params.alphaHashScale;
						object.material.transparent = !params.alphaHash;
						object.material.depthWrite = params.alphaHash;

						object.material.needsUpdate = true;

					}

				} );

				needsUpdate = true;

			}

			function animate() {

				requestAnimationFrame( animate );

				if ( needsUpdate ) {

					taaRenderPass.accumulate = false;
					taaRenderPass.sampleLevel = 0;

					needsUpdate = false;

				} else {

					taaRenderPass.accumulate = true;
					taaRenderPass.sampleLevel = params.sampleLevel;

				}

				composer.render();

			}

		</script>
	</body>
</html>
