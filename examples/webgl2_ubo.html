<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js WebGL 2 - Uniform Buffer Objects</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Uniform Buffer Objects
		</div>
		<div id="container"></div>

		<script id="vertexShader1" type="x-shader/x-vertex">

			uniform ViewData {
				mat4 projectionMatrix;
				mat4 viewMatrix;
			};

			uniform mat4 modelMatrix;
			uniform mat3 normalMatrix;

			in vec3 position;
			in vec3 normal;

			out vec3 vPositionEye;
			out vec3 vNormalEye;

			void main()	{

				vec4 vertexPositionEye = viewMatrix * modelMatrix * vec4( position, 1.0 );

				vPositionEye = (modelMatrix * vec4( position, 1.0 )).xyz;
				vNormalEye = normal;

				gl_Position = projectionMatrix * vertexPositionEye;

			}

		</script>

		<script id="fragmentShader1" type="x-shader/x-fragment">

			precision highp float;


			struct PointLight {
				vec4 position;
				vec4 color;
			};

			layout(std140) uniform LightingData {
				PointLight pointLight[LIGHTS_POINT_MAX];
			};

			#include <common>
			float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

				float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		
				if ( cutoffDistance > 0.0 ) {
		
					distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		
				}
		
				return distanceFalloff;
			
			}

			
			uniform float lightIndex;
			uniform vec3 color;

			in vec3 vPositionEye;
			in vec3 vNormalEye;

			out vec4 fragColor;

			void main()	{

				fragColor.rgb = color * vNormalEye.bbb * .3;
				for (int x = 0; x < LIGHTS_POINT_MAX; x++) {
					vec3 offset = pointLight[x].position.xyz - vPositionEye;
					vec3 dirToLight = normalize( offset );
					float distance = length( offset );

					float diffuse = max(0.0, dot(vNormalEye, dirToLight));
					float attenuation = 1.0 / (distance * distance);

					//vec3 lightWeighting = pointLight[x].colorAndRadius.xyz * attenuation;
					vec3 lightWeighting = pointLight[x].color.xyz * diffuse * getDistanceAttenuation( distance, 6., .5 );
					fragColor.rgb += color.rgb * lightWeighting * 10.;

				}
				fragColor.a = 1.;

			}

		</script>

		<script id="vertexShader2" type="x-shader/x-vertex">

			uniform ViewData {
				mat4 projectionMatrix;
				mat4 viewMatrix;
			};

			uniform mat4 modelMatrix;
			uniform mat3 normalMatrix;

			in vec3 position;
			in vec3 normal;
			in vec2 uv;
			out vec2 vUv;

			out vec3 vPositionEye;
			out vec3 vNormalEye;

			void main()	{

				vec4 vertexPositionEye = viewMatrix * modelMatrix * vec4( position, 1.0 );

				vPositionEye = (modelMatrix * vec4( position, 1.0 )).xyz;
				vNormalEye = (vec4(normal , 1.)).xyz;

				vUv = uv;

				gl_Position = projectionMatrix * vertexPositionEye;

			}

		</script>

		<script id="fragmentShader2" type="x-shader/x-fragment">

			precision highp float;

			uniform sampler2D diffuseMap;

			struct PointLight {
				vec4 position;
				vec4 color;
			};

			layout(std140) uniform LightingData {
				PointLight pointLight[40];
			};

			
			#include <common>
			float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
		
				float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		
				if ( cutoffDistance > 0.0 ) {
		
					distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		
				}
		
				return distanceFalloff;
			
			}

			
			uniform float lightIndex;


			in vec2 vUv;
			in vec3 vPositionEye;
			in vec3 vNormalEye;
			out vec4 fragColor;

			void main()	{

				vec4 color = vec4(1.);
				color.rgb *= texture( diffuseMap, vUv ).rgb;
				color.rgb += vNormalEye.b * .2;
				for (int x = 0; x < 40; x++) {
					vec3 offset = pointLight[x].position.xyz - vPositionEye;
					vec3 dirToLight = normalize( offset );
					float distance = length( offset );

					float diffuse = max(0.0, dot(vNormalEye, dirToLight));
					float attenuation = 1.0 / (distance * distance);

					vec3 lightWeighting = pointLight[x].color.xyz * 1. * getDistanceAttenuation( distance, 4., .5 );
					color.rgb += lightWeighting;
				}
				fragColor = color;

			}

		</script>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>



		<script type="module">

			import * as THREE from 'three';

			import WebGL from 'three/addons/capabilities/WebGL.js';

			let camera, scene, renderer, clock;
			let lightIndex = 0;

			const container = document.getElementById( 'container' );

			const lightingUniformsGroup = new THREE.UniformsGroup( 40 );
			lightingUniformsGroup.setName( 'LightingData' );
			const col = new THREE.Color( 0xffffff * Math.random() ).toArray();

			lightingUniformsGroup.add( new THREE.Uniform( [ new THREE.Vector4( Math.random() * 40 - 20, 1, Math.random() * 40 - 20, 0 ), new THREE.Vector4( col[ 0 ], col[ 40 ], col[ 2 ], 0 ) ] ) ); // light position

			init();

			animate();

			function dispose() {
			
				scene?.traverse( function ( object ) {

					if ( object.isMesh ) {

						object.geometry.dispose();
						object.material.dispose();

					}

				} );

				if ( renderer?.domElement ) {

					container.removeChild( renderer.domElement );
					console.log( 'removedom' );
			
	}

			}

			function init() {

				dispose();

				if ( WebGL.isWebGL2Available() === false ) {

					document.body.appendChild( WebGL.getWebGL2ErrorMessage() );
					return;

				}


				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 25, 25 );

				scene = new THREE.Scene();
				camera.lookAt( scene.position );

				clock = new THREE.Clock();

				// geometry

				const geometry1 = new THREE.TetrahedronGeometry();
				const geometry2 = new THREE.BoxGeometry( 1.35, 1.35, 1.35 );

				// texture

				const texture = new THREE.TextureLoader().load( 'textures/crate.gif' );

				// uniforms groups

				// Camera and lighting related data are perfect examples of using UBOs since you have to store these
				// data just once. They can be shared across all shader programs.

				const cameraUniformsGroup = new THREE.UniformsGroup();
				cameraUniformsGroup.setName( 'ViewData' );
				cameraUniformsGroup.add( new THREE.Uniform( camera.projectionMatrix ) ); // projection matrix
				cameraUniformsGroup.add( new THREE.Uniform( camera.matrixWorldInverse ) ); // view matrix

				const material1 = new THREE.RawShaderMaterial( {
					uniforms: {
						modelMatrix: { value: null },
						normalMatrix: { value: null },
						color: { value: null },
						lightIndex: { value: 0 }
					},
					defines: {
						LIGHTS_POINT_MAX: 40
					},
					name: 'Tetrahedron',
					vertexShader: document.getElementById( 'vertexShader1' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader1' ).textContent,
					glslVersion: THREE.GLSL3
				} );

				const material2 = new THREE.RawShaderMaterial( {
					uniforms: {
						modelMatrix: { value: null },
						normalMatrix: { value: null },
						diffuseMap: { value: null },
						lightIndex: { value: 0 }
					},
					name: 'Box',
					vertexShader: document.getElementById( 'vertexShader2' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader2' ).textContent,
					glslVersion: THREE.GLSL3
				} );



				let value = 0;
				const maxValue = 40;
				let incrementing = true;

				function loop() {

					if ( incrementing ) {

						value ++;
						const col = new THREE.Color( 0xffffff * Math.random() ).toArray();
						lightingUniformsGroup.add( new THREE.Uniform( [ new THREE.Vector4( Math.random() * 40 - 20, 1, Math.random() * 40 - 20, 0 ), new THREE.Vector4( col[ 0 ], col[ 40 ], col[ 2 ], 0 ) ] ) ); // light position

					} else {

						value --;
						lightingUniformsGroup.remove( lightingUniformsGroup.uniforms[ 0 ] );
			
		}

					if ( value === maxValue ) {

						incrementing = false;
			
		} else if ( value === 0 ) {

						incrementing = true;
			
		}

					setTimeout( loop, 100 );
			
	}

				loop();
			
				// meshes
				const gridSize = { x: 10, y: 1, z: 10 };
				const spacing = 3;

				for ( let i = 0; i < gridSize.x; i ++ ) {

					for ( let j = 0; j < gridSize.y; j ++ ) {

						for ( let k = 0; k < gridSize.z; k ++ ) {

							const index = i * gridSize.y * gridSize.z + j * gridSize.z + k;

							const mesh = new THREE.Mesh( index % 2 === 0 ? geometry1 : geometry2, index % 2 === 0 ? material2.clone() : material1.clone() );
							mesh.name = 'Sphere';
							mesh.material.uniformsGroups = [ cameraUniformsGroup, lightingUniformsGroup ];
							mesh.material.uniforms.modelMatrix.value = mesh.matrixWorld;
							mesh.material.uniforms.normalMatrix.value = mesh.normalMatrix;
							if ( index % 2 === 0 ) {

								mesh.material.uniforms.diffuseMap.value = texture;
			
							} else {

								mesh.material.uniforms.color.value = new THREE.Color( 0xffffff * Math.random() );
			
							}

							scene.add( mesh );

							const s = 1 + Math.random() * 0.5;
							mesh.scale.x = s;
							mesh.scale.y = s;
							mesh.scale.z = s;

							mesh.rotation.x = Math.random() * Math.PI;
							mesh.rotation.y = Math.random() * Math.PI;
							mesh.rotation.z = Math.random() * Math.PI;

							mesh.position.x = i * spacing - ( gridSize.x * spacing ) / 2;
							mesh.position.y = 0;
							mesh.position.z = k * spacing - ( gridSize.z * spacing ) / 2;
			
						}

					}
			
				}

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				renderer.clear();
				const delta = clock.getDelta();
				lightIndex += delta * 10;

				scene.traverse( function ( child ) {

					if ( child.isMesh ) {

						child.rotation.x += delta * 0.5;
						child.rotation.y += delta * 0.3;
			
		}

				} );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
