<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl2 - Multiple Render Targets</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #fff;
        font-family:Monospace;
        font-size:13px;
        text-align:center;
        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }
      a {
        color: #B2E9FF;
        font-weight: bold;
        pointer-events: auto;
      }
      
      canvas {
        position: absolute;
        top: 0;
        left: 0;
      }

      #info {
        pointer-events: none;
        position: absolute;
        left: 0;
        top: 0px; width: 100%;
        padding: 5px;
        display: inline-block;
      }
      
      #webgl2-error {
        margin: auto;
        margin-top: 40px;
        display: block;
        max-width: 400px;
        padding: 20px;
        background: #CE0808;
      }
    </style>

    <!-- Emit G-Buffer with WebGL1 -->
    <script id="gbuffer-vert-100" type="x-shader/x-vertex">
      #extension GL_EXT_draw_buffers : require
      uniform mat4 projectionMatrix;
      uniform mat4 modelViewMatrix;
      uniform mat3 normalMatrix;
      attribute vec4 position;
      attribute vec3 normal;
      attribute vec2 uv;
      varying vec3 vNormal;
      varying vec2 vUv;

      void main() {
        vUv = uv;

        // get smooth normals
        vec4 mvPosition = modelViewMatrix * position;

        vec3 transformedNormal = normalMatrix * normal;
        vNormal = normalize(transformedNormal);

        gl_Position = projectionMatrix * mvPosition;
      }
    </script>
    <script id="gbuffer-frag-100" type="x-shader/x-fragment">
      #extension GL_EXT_draw_buffers : require
      precision mediump float;

      uniform sampler2D map;
      uniform vec2 repeat;

      varying vec3 vNormal;
      varying vec2 vUv;

      void main() {
        // write color to G-Buffer
        gl_FragData[0] = texture2D(map, vUv * repeat);
        
        // write normals to G-Buffer
        gl_FragData[1] = vec4(normalize( vNormal ), 0.0);
      }
    </script>

    <!-- Emit G-Buffer with WebGL2 -->
    <script id="gbuffer-vert-300" type="x-shader/x-vertex">
      #version 300 es

      uniform mat4 projectionMatrix;
      uniform mat4 modelViewMatrix;
      uniform mat3 normalMatrix;
      in vec4 position;
      in vec3 normal;
      in vec2 uv;
      out vec3 vNormal;
      out vec2 vUv;

      void main() {
        vUv = uv;

        // get smooth normals
        vec4 mvPosition = modelViewMatrix * position;

        vec3 transformedNormal = normalMatrix * normal;
        vNormal = normalize(transformedNormal);

        gl_Position = projectionMatrix * mvPosition;
      }
    </script>
    <script id="gbuffer-frag-300" type="x-shader/x-fragment">
      #version 300 es
      precision mediump float;

      uniform sampler2D map;
      uniform vec2 repeat;

      in vec3 vNormal;
      in vec2 vUv;

      layout(location = 0) out vec3 diffuse;
      layout(location = 1) out vec3 normal;

      void main() {
        // write color to G-Buffer
        diffuse = texture(map, vUv * repeat).rgb;
        
        // write normals to G-Buffer
        normal = normalize( vNormal );
      }
    </script>

    <!-- Read G-Buffer and render to screen -->
    <script id="render-vert" type="x-shader/x-vertex">
      uniform mat4 projectionMatrix;
      uniform mat4 modelViewMatrix;

      attribute vec4 position;
      attribute vec2 uv;
      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * position;
      }
    </script>
    <script id="render-frag" type="x-shader/x-fragment">
      precision mediump float;

      varying vec2 vUv;
      uniform sampler2D tDiffuse;
      uniform sampler2D tNormal;
      uniform int showAttachment;

      void main() {
        vec3 diffuse = texture2D(tDiffuse, vUv).rgb;
        vec3 normal = texture2D(tNormal, vUv).rgb;

        gl_FragColor.rgb = mix(diffuse, normal, step(0.5, vUv.x));
        gl_FragColor.a = 1.0;
      }
    </script>

  </head>
  <body>
    <canvas></canvas>
    <div id="info">
      <a href="http://threejs.org" target="_blank">threejs</a> - WebGL2 - Multiple Render Targets<br/>
      Rendering geometry into a G-Buffer.<br/>
      Useful for a deferred shading pipelines.<br/>
      Created by <a href="http://twitter.com/mattdesl" target="_blank">@mattdesl</a>.
      
      <div id="webgl2-error" style="display: none;">
      Your browser does not support WebGL2. Please download <a href="https://nightly.mozilla.org/">Firefox Nightly</a> or <a href="https://www.google.com/chrome/browser/canary.html">Chrome Canary</a> and ensure it is enabled in your <strong>about:config</strong> or <strong>chrome://flags<strong>.
      </div>  
    </div>

    <script src="../build/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>

    <script>

      var camera, scene, renderer, controls;
      var target;
      var postScene, postCamera;
      var supportsMRT = false;

      init();
      animate();

      function init() {

        // Pass a WebGL2 canvas and context

        var canvas = document.querySelector( 'canvas' );
        var gl2;
        try {

          gl2 = canvas.getContext( 'webgl2' ) || canvas.getContext( 'experimental-webgl2' );

        } catch ( err ) {

          console.error( err );

        }

        // WebGL2 supports MRT, but WebGL1 only supports it with an extension
        if ( !gl2 ) {
          
          var dummyGL = document.createElement('canvas').getContext('webgl');
          if ( !dummyGL.getExtension('WEBGL_draw_buffers') ) {
            document.querySelector('#webgl2-error').style.display = 'block';
            return;            
          }

        }

        supportsMRT = true;
        renderer = new THREE.WebGLRenderer( {
          canvas: canvas,
          context: gl2
        } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        //

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.001, 1000 );
        camera.position.z = -4;

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.rotateSpeed = 0.35;

        // Create a multi render target with Float buffers
        target = new THREE.WebGLMultiRenderTarget( window.innerWidth, window.innerHeight );
        target.texture.format = THREE.RGBFormat;
        target.texture.minFilter = THREE.NearestFilter;
        target.texture.magFilter = THREE.NearestFilter;
        target.texture.generateMipmaps = false;
        target.stencilBuffer = false;
        target.depthBuffer = true;

        // Add an attachment for normals
        target.attachments.push( target.texture.clone() );

        // Name our G-Buffer attachments for debugging
        target.attachments[0].name = 'diffuse';
        target.attachments[1].name = 'normal';

        // Use float values for our normals
        target.attachments[1].type = THREE.FloatType;

        // Our scene
        scene = new THREE.Scene();

        // Add geometries
        setupScene();
        // Setup post-processing step
        setupPost();

        onWindowResize();
        window.addEventListener( 'resize', onWindowResize, false );

      }

      function setupPost () {

        // Setup post processing stage
        postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        var postMaterial = new THREE.RawShaderMaterial({
          vertexShader: document.querySelector('#render-vert').textContent.trim(),
          fragmentShader: document.querySelector('#render-frag').textContent.trim(),
          uniforms: {
            tDiffuse: { type: 't', value: target.attachments[0] },
            tNormal: { type: 't', value: target.attachments[1] },
            tPosition: { type: 't', value: target.attachments[2] },
            showAttachment: { type: 'i', value: 0 }
          }
        });
        var postPlane = new THREE.PlaneGeometry(2, 2);
        var postQuad = new THREE.Mesh(postPlane, postMaterial);
        postScene = new THREE.Scene();
        postScene.add(postQuad);

      }

      function setupScene () {
        var diffuse = new THREE.TextureLoader().load('textures/brick_diffuse.jpg');
        diffuse.wrapS = diffuse.wrapT = THREE.RepeatWrapping;

        var idVert = renderer.isWebGL2 ? '#gbuffer-vert-300' : '#gbuffer-vert-100';
        var idFrag = renderer.isWebGL2 ? '#gbuffer-frag-300' : '#gbuffer-frag-100';

        // Setup some geometries
        var geometry = new THREE.TorusKnotGeometry(1, 0.3, 128, 64);
        var material = new THREE.RawShaderMaterial({
          vertexShader: document.querySelector(idVert).textContent.trim(),
          fragmentShader: document.querySelector(idFrag).textContent.trim(),
          uniforms: {
            map: { type: 't', value: diffuse },
            repeat: { type: 'v2', value: new THREE.Vector2(5, 0.5) }
          }
        });
        
        var torus = new THREE.Mesh(geometry, material);
        scene.add(torus);
      }

      function onWindowResize() {

        var aspect = window.innerWidth / window.innerHeight;
        camera.aspect = aspect;
        camera.updateProjectionMatrix();

        var dpr = renderer.getPixelRatio();
        target.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        if ( !supportsMRT ) return;

        requestAnimationFrame( animate );
        controls.update();

        // render scene into target
        renderer.render( scene, camera, target );

        // render post FX
        renderer.render( postScene, postCamera );

      }
    </script>

  </body>
</html>
