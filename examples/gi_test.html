<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - simple global illumination</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - simple global illumination (<a href="http://www.iquilezles.org/www/articles/simplegi/simplegi.htm">article</a>)
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			class GIMesh extends THREE.Mesh {

				copy( source ) {

					super.copy( source );

					this.geometry = source.geometry.clone();

					return this;

				}

			}

			//

			const SimpleGI = function ( renderer, scene ) {

				const SIZE = 128, SIZE2 = SIZE * SIZE, BLOCKSIZE = SIZE2 * 4;

				const camera = new THREE.PerspectiveCamera( 90, 1, 0.01, 100 );

				scene.updateMatrixWorld( true );

				let clone = scene.clone();
				clone.autoUpdate = false;

				const rt = new THREE.WebGLRenderTarget( SIZE, SIZE );

				const normalMatrix = new THREE.Matrix3();

				const position = new THREE.Vector3();
				const normal = new THREE.Vector3();

                const color = new THREE.Color();
                const tmp = new THREE.Color();
                
				const buffer = new Uint8Array( BLOCKSIZE * SIZE );

                const object = torus = scene.children[ 0 ]; // torusKnot
                const geometry = object.geometry;

                const attributes = geometry.attributes;
                const positions = attributes.position.array;

                if ( attributes.color === undefined ) {

                    const colors = new Float32Array( positions.length );
                    geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setUsage( THREE.DynamicDrawUsage ) );

                }

                // console.error( attributes.color );

                const normals = attributes.normal.array;
                const colors = attributes.color.array;

                let free = [];
                let waiting = [];
                let bounces = 0;
				let currentVertex = 0;
                const totalVertex = positions.length / 3;

				function compute() {

					if ( bounces === 3 ) return;

                    if ( waiting.length > 0 ) {

                        const readback = waiting.shift();
                        renderer.readbackPixels( readback.glBuffer, buffer );

                        for ( let i = 0; i < readback.length; i ++ ) {

                            color.setScalar( 0 );

                            for ( let k = BLOCKSIZE * i, kl = ( BLOCKSIZE * i ) + BLOCKSIZE; k < kl; k += 4 ) {

                                tmp.fromArray( buffer, k )
                                color.add( tmp );

                            }

                            color.multiplyScalar( 1 / ( SIZE2 * 255 ) );
                            color.toArray( colors, 3 * ( readback.start + i ) );

                        }

                        attributes.color.needsUpdate = true;

                        free.push( readback.glBuffer );

                    } else {

                        const state = {
                            start: currentVertex,
                            length: Math.min( SIZE, totalVertex - currentVertex ),
                            glBuffer: ( free.length > 0 ) ? free.pop() : renderer.createReadbackBuffer( BLOCKSIZE * SIZE )
                        }


                        renderer.setRenderTarget( rt );

                        for ( let i = 0; i < state.length; i ++ ) {

                            const vertexIndex = state.start + i;
                            position.fromArray( positions, vertexIndex * 3 );
                            position.applyMatrix4( object.matrixWorld );

                            normal.fromArray( normals, vertexIndex * 3 );
                            normal.applyMatrix3( normalMatrix.getNormalMatrix( object.matrixWorld ) ).normalize();

                            camera.position.copy( position );
                            camera.lookAt( position.add( normal ) );

                            renderer.render( clone, camera );

                            const options = {
                                interval: 8,
                                readback: false,
                                glBuffer: state.glBuffer,
                                sync: ( i == state.length - 1 ),
                                byteOffset: SIZE2 * 4 * i,
                            };

                            renderer.readRenderTargetPixelsAsync( rt, 0, 0, SIZE, SIZE, buffer, undefined, options )
                                .then( ( result ) => { 

                                    if ( result ) {

                                        waiting.push( state );

                                    }

                            } );

                        };


                        currentVertex += state.length;

                        if ( currentVertex >= totalVertex ) {

                            clone = scene.clone();
                            clone.autoUpdate = false;

                            bounces ++;
                            currentVertex = 0;

                        }

                    }

                    setTimeout( compute, 3 )

                }

				setTimeout( compute )

			};

			//

			let camera, scene, renderer, torus;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.z = 4;

				scene = new THREE.Scene();

				// torus knot

				const torusGeometry = new THREE.TorusKnotGeometry( 0.75, 0.3, 128, 32, 1 );
				const material = new THREE.MeshBasicMaterial( { vertexColors: true } );

				const torusKnot = new GIMesh( torusGeometry, material );
				scene.add( torusKnot );

				// room

				const materials = [];

				for ( let i = 0; i < 8; i ++ ) {

					materials.push( new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, side: THREE.BackSide } ) );

				}

				const boxGeometry = new THREE.BoxGeometry( 3, 3, 3 );

				const box = new THREE.Mesh( boxGeometry, materials );
				scene.add( box );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				new SimpleGI( renderer, scene );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 10;

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				renderer.setRenderTarget( null );
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
