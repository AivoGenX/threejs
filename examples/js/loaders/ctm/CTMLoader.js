/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *	http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *	http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CTMLoader = function () {

};

THREE.CTMLoader.prototype.constructor = THREE.CTMLoader;

// Load multiple CTM parts defined in JSON

THREE.CTMLoader.prototype.loadParts = function ( url, callback, parameters ) {

	parameters = parameters || {};

	var scope = this;

	var xhr = new XMLHttpRequest();

	var basePath = parameters.basePath ? parameters.basePath : THREE.LoaderUtils.extractUrlBase( url );

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var jsonObject = JSON.parse( xhr.responseText );

				var materials = [], geometries = [], counter = 0;

				function callbackFinal( geometry ) {

					counter += 1;

					geometries.push( geometry );

					if ( counter === jsonObject.offsets.length ) {

						callback( geometries, materials );

					}

				}


				// init materials

				for ( var i = 0; i < jsonObject.materials.length; i ++ ) {

					materials[ i ] = scope.createMaterial( jsonObject.materials[ i ], basePath );

				}

				// load joined CTM file

				var partUrl = basePath + jsonObject.data;
				var parametersPart = { useWorker: parameters.useWorker, worker: parameters.worker, offsets: jsonObject.offsets };
				scope.load( partUrl, callbackFinal, parametersPart );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.setRequestHeader( "Content-Type", "text/plain" );
	xhr.send( null );

};

// Load CTMLoader compressed models
//	- parameters
//		- url (required)
//		- callback (required)

THREE.CTMLoader.prototype.load = function ( url, callback, parameters ) {

	parameters = parameters || {};

	var scope = this;

	var offsets = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];

	var xhr = new XMLHttpRequest(),
		callbackProgress = null;

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var binaryData = new Uint8Array( xhr.response );

				var s = Date.now();

				if ( parameters.useWorker ) {

					var worker = parameters.worker || new Worker( 'js/loaders/ctm/CTMWorker.js' );

					worker.onmessage = function ( event ) {

						var files = event.data;

						for ( var i = 0; i < files.length; i ++ ) {

							var ctmFile = files[ i ];

							var e1 = Date.now();
							// console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );

							scope.createModel( ctmFile, callback );

							var e = Date.now();
							console.log( "model load time [worker]: " + ( e - e1 ) + " ms, total: " + ( e - s ) );

						}


					};

					worker.postMessage( { "data": binaryData, "offsets": offsets }, [ binaryData.buffer ] );

				} else {

					for ( var i = 0; i < offsets.length; i ++ ) {

						var stream = new CTM.Stream( binaryData );
						stream.offset = offsets[ i ];

						var ctmFile = new CTM.File( stream );

						scope.createModel( ctmFile, callback );

					}

					//var e = Date.now();
					//console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );

				}

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState === 3 ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === 2 ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	};

	xhr.open( "GET", url, true );
	xhr.responseType = "arraybuffer";

	xhr.send( null );

};


THREE.CTMLoader.prototype.createModel = function ( file, callback ) {

	var Model = function () {

		THREE.BufferGeometry.call( this );

		this.materials = [];

		var indices = file.body.indices;
		var positions = file.body.vertices;
		var normals = file.body.normals;

		var uvs, colors;

		var uvMaps = file.body.uvMaps;

		if ( uvMaps !== undefined && uvMaps.length > 0 ) {

			uvs = uvMaps[ 0 ].uv;

		}

		var attrMaps = file.body.attrMaps;

		if ( attrMaps !== undefined && attrMaps.length > 0 && attrMaps[ 0 ].name === 'Color' ) {

			colors = attrMaps[ 0 ].attr;

		}

		this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		if ( normals !== undefined ) {

			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

		}

		if ( uvs !== undefined ) {

			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		}

		if ( colors !== undefined ) {

			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 4 ) );

		}

	};

	Model.prototype = Object.create( THREE.BufferGeometry.prototype );
	Model.prototype.constructor = Model;

	var geometry = new Model();

	// compute vertex normals if not present in the CTM model
	if ( geometry.attributes.normal === undefined ) {

		geometry.computeVertexNormals();

	}

	callback( geometry );

};

THREE.CTMLoader.prototype.createMaterial = ( function () {

	var BlendingMode = {
		NoBlending: THREE.NoBlending,
		NormalBlending: THREE.NormalBlending,
		AdditiveBlending: THREE.dditiveBlending,
		SubtractiveBlending: THREE.SubtractiveBlending,
		MultiplyBlending: THREE.MultiplyBlending,
		CustomBlending: THREE.CustomBlending
	};

	var color = new THREE.Color();
	var textureLoader = new THREE.TextureLoader();
	var materialLoader = new THREE.MaterialLoader();

	return function createMaterial( m, texturePath, crossOrigin ) {

		// convert from old material format

		var textures = {};

		function loadTexture( path, repeat, offset, wrap, anisotropy ) {

			var fullPath = texturePath + path;
			var loader = THREE.Loader.Handlers.get( fullPath );

			var texture;

			if ( loader !== null ) {

				texture = loader.load( fullPath );

			} else {

				textureLoader.setCrossOrigin( crossOrigin );
				texture = textureLoader.load( fullPath );

			}

			if ( repeat !== undefined ) {

				texture.repeat.fromArray( repeat );

				if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

			}

			if ( offset !== undefined ) {

				texture.offset.fromArray( offset );

			}

			if ( wrap !== undefined ) {

				if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
				if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

				if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
				if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

			}

			if ( anisotropy !== undefined ) {

				texture.anisotropy = anisotropy;

			}

			var uuid = THREE.Math.generateUUID();

			textures[ uuid ] = texture;

			return uuid;

		}

		//

		var json = {
			uuid: THREE.Math.generateUUID(),
			type: 'MeshLambertMaterial'
		};

		for ( var name in m ) {

			var value = m[ name ];

			switch ( name ) {

				case 'DbgColor':
				case 'DbgIndex':
				case 'opticalDensity':
				case 'illumination':
					break;
				case 'DbgName':
					json.name = value;
					break;
				case 'blending':
					json.blending = BlendingMode[ value ];
					break;
				case 'colorAmbient':
				case 'mapAmbient':
					console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
					break;
				case 'colorDiffuse':
					json.color = color.fromArray( value ).getHex();
					break;
				case 'colorSpecular':
					json.specular = color.fromArray( value ).getHex();
					break;
				case 'colorEmissive':
					json.emissive = color.fromArray( value ).getHex();
					break;
				case 'specularCoef':
					json.shininess = value;
					break;
				case 'shading':
					if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
					if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
					if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
					break;
				case 'mapDiffuse':
					json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
					break;
				case 'mapDiffuseRepeat':
				case 'mapDiffuseOffset':
				case 'mapDiffuseWrap':
				case 'mapDiffuseAnisotropy':
					break;
				case 'mapEmissive':
					json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
					break;
				case 'mapEmissiveRepeat':
				case 'mapEmissiveOffset':
				case 'mapEmissiveWrap':
				case 'mapEmissiveAnisotropy':
					break;
				case 'mapLight':
					json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
					break;
				case 'mapLightRepeat':
				case 'mapLightOffset':
				case 'mapLightWrap':
				case 'mapLightAnisotropy':
					break;
				case 'mapAO':
					json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
					break;
				case 'mapAORepeat':
				case 'mapAOOffset':
				case 'mapAOWrap':
				case 'mapAOAnisotropy':
					break;
				case 'mapBump':
					json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
					break;
				case 'mapBumpScale':
					json.bumpScale = value;
					break;
				case 'mapBumpRepeat':
				case 'mapBumpOffset':
				case 'mapBumpWrap':
				case 'mapBumpAnisotropy':
					break;
				case 'mapNormal':
					json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
					break;
				case 'mapNormalFactor':
					json.normalScale = value;
					break;
				case 'mapNormalRepeat':
				case 'mapNormalOffset':
				case 'mapNormalWrap':
				case 'mapNormalAnisotropy':
					break;
				case 'mapSpecular':
					json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
					break;
				case 'mapSpecularRepeat':
				case 'mapSpecularOffset':
				case 'mapSpecularWrap':
				case 'mapSpecularAnisotropy':
					break;
				case 'mapMetalness':
					json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
					break;
				case 'mapMetalnessRepeat':
				case 'mapMetalnessOffset':
				case 'mapMetalnessWrap':
				case 'mapMetalnessAnisotropy':
					break;
				case 'mapRoughness':
					json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
					break;
				case 'mapRoughnessRepeat':
				case 'mapRoughnessOffset':
				case 'mapRoughnessWrap':
				case 'mapRoughnessAnisotropy':
					break;
				case 'mapAlpha':
					json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
					break;
				case 'mapAlphaRepeat':
				case 'mapAlphaOffset':
				case 'mapAlphaWrap':
				case 'mapAlphaAnisotropy':
					break;
				case 'flipSided':
					json.side = THREE.BackSide;
					break;
				case 'doubleSided':
					json.side = THREE.DoubleSide;
					break;
				case 'transparency':
					console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
					json.opacity = value;
					break;
				case 'depthTest':
				case 'depthWrite':
				case 'colorWrite':
				case 'opacity':
				case 'reflectivity':
				case 'transparent':
				case 'visible':
				case 'wireframe':
					json[ name ] = value;
					break;
				case 'vertexColors':
					if ( value === true ) json.vertexColors = THREE.VertexColors;
					if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
					break;
				default:
					console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
					break;

			}

		}

		if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
		if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

		if ( json.opacity < 1 ) json.transparent = true;

		materialLoader.setTextures( textures );

		return materialLoader.parse( json );

	};

} )();
