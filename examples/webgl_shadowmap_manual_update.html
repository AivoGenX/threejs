<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - shadow map manual update</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>

		<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - shadowmap manual update<br />
		move camera with WASD / RF + mouse<br />
		t: toggle HUD
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from './jsm/libs/stats.module.js';

			import { FirstPersonControls } from './jsm/controls/FirstPersonControls.js';
			import { FontLoader } from './jsm/loaders/FontLoader.js';
			import { TextGeometry } from './jsm/geometries/TextGeometry.js';
			import { ShadowMapViewer } from './jsm/utils/ShadowMapViewer.js';

			const SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 2048;

			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;
			const FLOOR = - 250;

			let camera, controls, scene, renderer;
			let container, stats;

			const NEAR = 10, FAR = 3000;

			let light;
			let lightShadowMapViewer;

			const textMeshes = [];

			let needToRenderShadows = true;

			const clock = new THREE.Clock();

			let showHUD = false;

			init();
			animate();


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// CAMERA

				camera = new THREE.PerspectiveCamera( 23, SCREEN_WIDTH / SCREEN_HEIGHT, NEAR, FAR );
				camera.position.set( 700, 50, 1900 );

				// SCENE

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x59472b );
				scene.fog = new THREE.Fog( 0x59472b, 1000, FAR );

				// LIGHTS

				const ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );

				light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 10, 0.3 );
				light.position.set( 200, 1200, - 3000 );
				light.target.position.set( 0, 0, 0 );

				light.castShadow = true;
				light.shadow.camera.near = 1200;
				light.shadow.camera.far = 5000;
				light.shadow.bias = 0.0001;

				light.shadow.mapSize.width = SHADOW_MAP_WIDTH;
				light.shadow.mapSize.height = SHADOW_MAP_HEIGHT;

				scene.add( light );

				createHUD();
				createScene();

				// RENDERER

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				container.appendChild( renderer.domElement );

				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.autoClear = false;

				//

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.shadowMap.autoUpdate = false;

				// CONTROLS

				controls = new FirstPersonControls( camera, renderer.domElement );

				controls.lookSpeed = 0.0125;
				controls.movementSpeed = 500;
				controls.noFly = false;
				controls.lookVertical = true;

				controls.lookAt( scene.position );

				// STATS

				stats = new Stats();
				//container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'keydown', onKeyDown );

			}

			function onWindowResize() {

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;

				camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				camera.updateProjectionMatrix();

				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				controls.handleResize();

			}

			function onKeyDown( event ) {

				switch ( event.keyCode ) {

					case 84:	/*t*/
						showHUD = ! showHUD;
						break;

				}

			}

			function createHUD() {

				lightShadowMapViewer = new ShadowMapViewer( light );
				lightShadowMapViewer.position.x = 10;
				lightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 4 ) - 10;
				lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;
				lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;
				lightShadowMapViewer.update();

			}

			function createScene( ) {

				// GROUND

				const geometry = new THREE.PlaneGeometry( 100, 100 );
				const planeMaterial = new THREE.MeshPhongMaterial( { color: 0xffb851 } );

				const ground = new THREE.Mesh( geometry, planeMaterial );

				ground.position.set( 0, FLOOR, 0 );
				ground.rotation.x = - Math.PI / 2;
				ground.scale.set( 100, 100, 100 );

				ground.castShadow = false;
				ground.receiveShadow = true;

				scene.add( ground );

				// TEXT

				function addTextMesh( font, text, y, visible ) {

					const textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000, specular: 0xffffff } );

					const textGeo = new TextGeometry( text, {

						font: font,

						size: 100,
						height: 50,
						curveSegments: 12,

						bevelThickness: 2,
						bevelSize: 5,
						bevelEnabled: true

					} );

					textGeo.computeBoundingBox();
					const centerOffset = - 0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

					const mesh = new THREE.Mesh( textGeo, textMaterial );
					mesh.position.x = centerOffset;
					mesh.position.y = y;

					mesh.visible = visible;

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					textMeshes.push( mesh );

					scene.add( mesh );

				}

				const loader = new FontLoader();
				loader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {

					addTextMesh( font, 'MYSTERIOUS', FLOOR + 220, false );

					addTextMesh( font, 'THREE.JS', FLOOR + 67, true );

					needToRenderShadows = true;

				} );

				// CUBES

				const cubes1 = new THREE.Mesh( new THREE.BoxGeometry( 1500, 220, 150 ), planeMaterial );

				cubes1.position.y = FLOOR - 50;
				cubes1.position.z = 20;

				cubes1.castShadow = true;
				cubes1.receiveShadow = true;

				scene.add( cubes1 );

				const cubes2 = new THREE.Mesh( new THREE.BoxGeometry( 1600, 170, 250 ), planeMaterial );

				cubes2.position.y = FLOOR - 50;
				cubes2.position.z = 20;

				cubes2.castShadow = true;
				cubes2.receiveShadow = true;

				scene.add( cubes2 );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();

				if ( needToRenderShadows ) {

					// The scene can be setup for a different way when rendering shadow maps since we're manually updating shadow maps.

					if ( textMeshes.length > 0 ) {

						textMeshes[ 0 ].visible = true;

					}

					renderer.renderShadowMap( [ light ], scene, camera );

					needToRenderShadows = false;

					if ( textMeshes.length > 0 ) {

						textMeshes[ 0 ].visible = false;

					}

				}

				controls.update( delta );

				renderer.clear();
				renderer.render( scene, camera );

				// Render debug HUD with shadow map

				if ( showHUD ) {

					lightShadowMapViewer.render( renderer );

				}

			}

		</script>

	</body>
</html>
