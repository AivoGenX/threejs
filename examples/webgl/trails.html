<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - trails</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="../shared/styles/default.css" />
	</head>
	<body>
		<script src="../../build/three.js"></script>
		<script src="../shared/js/libs/stats.min.js"></script>
		<script src="../shared/s3age/s3age.js"></script>

		<script>
			var stage = new S3age("body", {
				/**
				 * Enable Trails turns on overdrawing on the renderer. Each render loop, the
				 * particle system will be drawn over the last draw, leaving the old pixels in place.
				 */
				renderer: {
					preserveDrawingBuffer: true
				},
				camera: {
					fov:  60,
					near: 1,
					far:  10000
				}
			});

			// The other property to enable overdraw.
			stage.renderer.autoClearColor = false;
			// A performance optimization
			// Since there are a lot of points, and every point gets drawn,
			// it's not important to sort them into depth order.
			stage.renderer.sortObjects = false;

			particleSystem();
			controls();
			stats();

			/**
			 * Create a couple thousand points of a half-dozen colors.
			 */
			function particleSystem() {
				var colors = [ 0x000000, 0xff0080, 0x8000ff, 0xffffff ];
				var geometry = new THREE.Geometry();

				for ( var i = 0; i < 2000; i ++ ) {

					var vertex = new THREE.Vector3();
					vertex.x = Math.random() * 4000 - 2000;
					vertex.y = Math.random() * 4000 - 2000;
					vertex.z = Math.random() * 4000 - 2000;
					geometry.vertices.push( vertex );

					geometry.colors.push(
						new THREE.Color( colors[ Math.floor( Math.random() * colors.length ) ] )
					);
				}

				var material = new THREE.ParticleBasicMaterial({
					size: 1,
					vertexColors: THREE.VertexColors,
					depthTest: false,
					opacity: 0.5,
					sizeAttenuation: false,
					transparent: true
				});

				var mesh = new THREE.ParticleSystem( geometry, material );
				stage.scene.add( mesh );
			}

			function stats() {
				var stats = stage.stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				document.body.appendChild( stats.domElement );
			}

			function controls() {
				var mouseX = 0, mouseY = 0;
				var windowHalfX = window.innerWidth / 2;
				var windowHalfY = window.innerHeight / 2;

				var camera = stage.camera;
				// The mouse starts at <0, 0>, so the large X value will
				// cause the camera to start by spinning to the rest position
				camera.position.set( 100000, 0, 3200 );
				// Minimum for controls is an update function. Called every render frame.
				stage.controls = {
					update: function(){
						// Move the camera towards the mouse, with some damping.
						camera.position.x += ( mouseX - camera.position.x ) * .05;
						camera.position.y += ( - mouseY - camera.position.y ) * .05;

						// Keep the camera pointed at the center of the scene
						camera.lookAt( stage.scene.position );
					}
				};

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				function onDocumentMouseMove(event) {
					// Use the center of the screen, instead of top-left, then scale by 10.
					mouseX = ( event.clientX - windowHalfX ) * 10;
					mouseY = ( event.clientY - windowHalfY ) * 10;
				}
			}

		</script>
	</body>
</html>
