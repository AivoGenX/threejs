<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - modified</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				font-weight: bold;
				overflow:hidden;
			}

			a {
				color: #ffffff;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}

			#oldie {
				background:rgb(200,100,0) !important;
				color:#fff;
			}

		</style>
	</head>

	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> wegbl - modified material.
			<a href="http://graphics.cs.williams.edu/data/meshes.xml#14" target="_blank" rel="noopener">Lee Perry-Smith</a> head.
			Author <a href="http://dusanbosnjak.com" target="_blank" rel="noopener">@pailhead.</a>
		</div>

		<script src="../build/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/SpecGlossMultiUVInstanceExample.js"></script>

		<script src="js/CurveExtras.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var camera, scene, renderer, stats;

			var mesh, material;

			var mouseX = 0;
			var mouseY = 0;

			var targetX = 0;
			var targetY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var gui = new dat.GUI()

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1200;

				scene = new THREE.Scene();

				var light = new THREE.DirectionalLight( 0xffffff, 0.4 );
				light.position.set( 100, 260, 160 );
				
				light.castShadow = true;
				light.shadow.camera.left = - 240;
				light.shadow.camera.right = 240;
				light.shadow.camera.top = 240;
				light.shadow.camera.bottom = - 240;
				light.shadow.camera.near = 10;
				light.shadow.camera.far = 1500;

				light.shadow.bias = - 0.001;
				light.shadow.mapSize.width = 512;
				light.shadow.mapSize.height = 512;
				scene.add(light)


				// light shadow camera helper
				light.shadowCameraHelper = new THREE.CameraHelper( light.shadow.camera );
				scene.add( light.shadowCameraHelper );
				scene.add( new THREE.AmbientLight( 0xffffff, 0.17 ) );

				var ground = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 800, 800 ).rotateX( - Math.PI / 2 ),
					new THREE.MeshPhongMaterial( { color: 0x888888 } )
				);
				ground.position.set( 0, - 200, 0 );
				ground.receiveShadow = true;
	
				scene.add( ground );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				renderer.shadowMap.enabled = true;
				//

				stats = new Stats();
				document.body.appendChild( stats.dom );

				// EVENTS

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );



				var texture = new THREE.TextureLoader().load( `textures/roughness_map.jpg` )
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping

				var envMap = new THREE.TextureLoader().load( `textures/metal.jpg`, function ( texture ) {
	
					texture.mapping = THREE.SphericalReflectionMapping;
					texture.encoding = THREE.sRGBEncoding;
					if ( mesh ) mesh.material.needsUpdate = true;
	
				} );

				var material = new THREE.MeshStandardMaterial({
					color: 0xffb54a,
					envMap: envMap,
				})

				mesh = new THREE.Mesh(new THREE.SphereBufferGeometry(10), material)
				scene.add(mesh)
				mesh.castShadow = true
				mesh.receiveShadow = true

				decorateMaterialWithSpecGloss(material)
				material.glossinessMap = texture
				material.specularMap = texture
				decorateMaterialWithPerMapTransforms(material)

				gui.add( material.glossinessMapRepeat,'x',0,10).onChange(material.glossinessMapUpdateMatrix)
				gui.add( material.glossinessMapRepeat,'y',0,10).onChange(material.glossinessMapUpdateMatrix)
				gui.add( material.glossinessMapOffset,'x',0,1).onChange(material.glossinessMapUpdateMatrix)
				gui.add( material.glossinessMapOffset,'x',0,1).onChange(material.glossinessMapUpdateMatrix)
				gui.add( material, 'glossinessMapRotation',0,1).onChange(material.glossinessMapUpdateMatrix)

				//instancing
				const INSTANCES = 256;
				var knot = new THREE.Curves.TorusKnot( 60 );
				var positions = knot.getSpacedPoints( INSTANCES );

				var offsets = new Float32Array( INSTANCES * 3 ); // xyz
				var scales = new Float32Array( INSTANCES * 1 ); // s
				for ( var i = 0, l = INSTANCES; i < l; i ++ ) {

					var index = 3 * i;

					// per-instance position offset
					offsets[ index ] = positions[ i ].x;
					offsets[ index + 1 ] = positions[ i ].y;
					offsets[ index + 2 ] = positions[ i ].z;

					// per-instance scale variation
					scales[ i ] = 1 + 0.5 * Math.sin( 32 * Math.PI * i / INSTANCES );

				}
				mesh.geometry = new THREE.InstancedBufferGeometry().copy(mesh.geometry)
				mesh.geometry.maxInstancedCount = INSTANCES
				console.log(mesh.geometry)
				mesh.geometry.addAttribute( 'instanceOffset', new THREE.InstancedBufferAttribute( offsets, 3 ) );
				mesh.geometry.addAttribute( 'instanceScale', new THREE.InstancedBufferAttribute( scales, 1 ) );

				mesh.customDepthMaterial = decorateMaterialWithSimpleInstancing(new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking }))
				decorateMaterialWithSimpleInstancing(material)
			}


			function onWindowResize( event ) {

				var width = window.innerWidth;
				var height = window.innerHeight;

				windowHalfX = width / 2;
				windowHalfY = height / 2;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX );
				mouseY = ( event.clientY - windowHalfY );
				console.log
			}


			function animate() {

				requestAnimationFrame( animate );

				render();

				stats.update();

			}

			function render() {

				targetX = mouseX * .001;
				targetY = mouseY * .001;

				if ( mesh ) {

					mesh.rotation.y += 0.05 * ( targetX - mesh.rotation.y );
					mesh.rotation.x += 0.05 * ( targetY - mesh.rotation.x );

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
