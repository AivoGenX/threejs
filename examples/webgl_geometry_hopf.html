<!DOCTYPE html>
<html>

<head>
    <title>three.js webgl - geometry - Hopf Application</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        canvas {
            width: 100%;
            height: 100%;
        }
        #container {
            display: flex;
        }
        #gui {
            position: absolute;
            top: 2px;
            left: 2px;
        }
    </style>
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Hopf application
    </div>

    <div id="container"></div>


    <script type="module">

        import * as THREE from '../build/three.module.js';
        import { ParametricGeometry } from './jsm/geometries/ParametricGeometry.js';

        import { GUI } from './jsm/libs/lil-gui.module.min.js';


        // quaternion stuff
        let quatmultiply, quatdivide, quatexp, quatlog;

        let startingPoint;

        let seq_len; // function to construct the array [0, 1, ..., n-1]

        let KochanekBartels; // the function which makes the spline

        const keyBalls = new Array(6); // the red balls on the sphere
        const keyPoints = new Array(6);
        const rho = 5; // radius of the sphere
        let equator; // function to draw the equator
        let CatmullRom; // to interpolate the yellow points 

        const container = document.getElementById("container");
        let container1, container2;
        let lgcontrols;
        let camera1, camera2, object1, object2, scene1, scene2, renderer1, renderer2;
        const windowHalfX = window.innerWidth / 2;
        const windowY = window.innerHeight;
        let renderSphericalCurve, renderHopfTorus;

        quaternionStuff();
        KochanekBartelsSpline();
        prep();
        init();
        init1();
        init2();



        function quaternionStuff() {

            quatmultiply = (q, scalar) => (
                new THREE.Quaternion(scalar * q.x, scalar * q.y, scalar * q.z, scalar * q.w)
            );

            quatdivide = (q, scalar) => (
                new THREE.Quaternion(q.x / scalar, q.y / scalar, q.z / scalar, q.w / scalar)
            );

            quatlog = (q) => {
                const qnorm = q.length();
                const w = q.w;
                let v = q.clone();
                v.w = 0;
                const vnorm = v.length();
                if (vnorm == 0) {
                    return new THREE.Quaternion(0, 0, 0, Math.log(qnorm));
                }
                const a = Math.acos(w / qnorm) / vnorm;
                return new THREE.Quaternion(a * q.x, a * q.y, a * q.z, Math.log(qnorm));
            };

            quatexp = (q) => {
                const w = q.w;
                let v = q.clone();
                v.w = 0;
                const vnorm = v.length();
                if (vnorm == 0) {
                    return new THREE.Quaternion(0, 0, 0, Math.exp(w));
                }
                const b = Math.exp(w) * Math.sin(vnorm) / vnorm;
                return new THREE.Quaternion(b * q.x, b * q.y, b * q.z, Math.exp(w) * Math.cos(vnorm));
            };

        }


        function KochanekBartelsSpline() {

            const bisect_right = (a, x) => {
                var lo = 0;
                var hi = a.length;
                do {
                    const mid = (lo + hi) >>> 1;
                    if (a[mid] - x <= 0) lo = mid + 1;
                    else hi = mid;
                } while (lo < hi);
                return lo;
            };

            seq_len = (n) => {
                const seq = new Array(n);
                for (let i = 0; i < n; i++) {
                    seq[i] = i;
                }
                return seq;
            };

            const _select_segment_and_normalize_t = (segments, keyTimes, t) => {
                const lastTime = keyTimes[keyTimes.length - 1];
                let idx;
                if (t < keyTimes[0]) {
                    throw "`t` is too small."
                } else if (t < lastTime) {
                    idx = bisect_right(keyTimes, t) - 1;
                } else if (t == lastTime) {
                    idx = keyTimes.length - 2;
                } else {
                    throw "`t` is too big.";
                }
                const t0 = keyTimes[idx];
                const t1 = keyTimes[idx + 1];
                const delta_t = t1 - t0;
                return {
                    "segment": segments[idx],
                    "time": (t - t0) / delta_t,
                    "difftime": delta_t
                };
            };

            const _reduce_de_casteljau = (segment, t) => {
                let l = segment.length;
                if (l < 2) {
                    throw "Segment must have at least two quaternions.";
                }
                while (l > 2) {
                    const newsegment = new Array(l - 1);
                    for (let i = 0; i < l - 1; i++) {
                        let q = new THREE.Quaternion();
                        q.slerpQuaternions(segment[i], segment[i + 1], t);
                        newsegment[i] = q.clone();
                    }
                    segment = newsegment.map(function (quat) { return quat.clone(); });
                    l = segment.length;
                }
                return segment;
            };

            const DeCasteljau = (segments, keyTimes) => {
                const n_segments = segments.length;
                if (typeof (keyTimes) == "undefined") {
                    keyTimes = seq_len(n_segments + 1);
                } else if (keyTimes.length != n_segments + 1) {
                    throw "Number of key times must be one more than number of segments.";
                }
                const evaluate = function (t) {
                    const x = _select_segment_and_normalize_t(segments, keyTimes, t);
                    const segment = x["segment"];
                    const s = x["time"];
                    const quats = _reduce_de_casteljau(segment, s);
                    let q = new THREE.Quaternion();
                    q.slerpQuaternions(quats[0], quats[1], s);
                    return q;
                };
                return evaluate;
            };

            const _calculate_control_quaternions = (quaternions, times, tcb) => {
                const q_1 = quaternions[0].clone();
                const q01 = quaternions[1].clone();
                const q02 = quaternions[1].clone();
                const q03 = quaternions[1].clone();
                const q1 = quaternions[2].clone();
                const t_1 = times[0];
                const t0 = times[1];
                const t1 = times[2];
                const T = tcb[0];
                const C = tcb[1];
                const B = tcb[2];
                const a = (1 - T) * (1 + C) * (1 + B);
                const b = (1 - T) * (1 - C) * (1 - B);
                const c = (1 - T) * (1 - C) * (1 + B);
                const d = (1 - T) * (1 + C) * (1 - B);
                const q_in = q01.multiply(q_1.invert());
                const q_out = q1.multiply(q02.invert());
                let v_in = quatdivide(quatlog(q_in), t0 - t_1);
                let v_out = quatdivide(quatlog(q_out), t1 - t0);
                v_in = new THREE.Vector3(v_in.x, v_in.y, v_in.z);
                v_out = new THREE.Vector3(v_out.x, v_out.y, v_out.z);
                const V0 = (weight_in, weight_out) => {
                    const vin = v_in.clone();
                    const vout = v_out.clone();
                    const va = vin.multiplyScalar(weight_in * (t1 - t0));
                    const vb = vout.multiplyScalar(weight_out * (t0 - t_1));
                    return (va.add(vb)).divideScalar(t1 - t_1);
                };
                const out = new Array(2);
                const v0cd = V0(c, d).multiplyScalar((t0 - t_1) / 3);
                const qcd = new THREE.Quaternion(-v0cd.x, -v0cd.y, -v0cd.z, 0);
                out[0] = quatexp(qcd).multiply(q03);
                const v0ab = V0(a, b).multiplyScalar((t1 - t0) / 3);
                const qab = new THREE.Quaternion(v0ab.x, v0ab.y, v0ab.z, 0);
                out[1] = quatexp(qab).multiply(q03);
                return out;
            };

            const _check_endcondition = (endcondition, rotors, times) => {
                const n_rotors = rotors.length;
                const n_times = times.length;
                let triples_times, triples_rotors;
                if (endcondition == "closed") {
                    let prefix = rotors[n_rotors - 2].clone();
                    if (prefix.dot(rotors[0]) < 0) {
                        prefix = quatmultiply(prefix, -1);
                    }
                    let suffix = rotors[1].clone();
                    if (rotors[n_rotors - 1].dot(suffix) < 0) {
                        suffix = quatmultiply(suffix, -1);
                    }
                    rotors = [prefix].concat(rotors).concat([suffix]);
                    times =
                        [times[0] - (times[n_times - 1] - times[n_times - 2])]
                            .concat(times)
                            .concat([times[n_times - 1] + (times[1] - times[0])]);
                    triples_times = seq_len(n_times).map(function (i) {
                        return [times[i], times[i + 1], times[i + 2]]
                    });
                    triples_rotors = seq_len(n_rotors).map(function (i) {
                        return [rotors[i], rotors[i + 1], rotors[i + 2]]
                    });
                } else {
                    triples_times = seq_len(n_times).map(function (i) {
                        return [times[i], times[i + 1], times[i + 2]]
                    });
                    triples_rotors = seq_len(n_rotors - 2).map(function (i) {
                        return [rotors[i], rotors[i + 1], rotors[i + 2]]
                    });
                }
                return {
                    "times": triples_times,
                    "rotors": triples_rotors
                };
            };

            const _canonicalized = (quaternions) => {
                const n_quaternions = quaternions.length;
                const out = new Array(n_quaternions);
                let p = new THREE.Quaternion(0, 0, 0, 1);
                for (let i = 0; i < n_quaternions; i++) {
                    let q = quaternions[i].clone();
                    if (p.dot(q) < 0) {
                        q = quatmultiply(q, -1);
                    }
                    out[i] = q.clone();
                    p = q.clone();
                }
                return out;
            };

            const _check_keyRotors = (keyRotors, closed) => {
                if (keyRotors.length < 2) {
                    throw "At least two key rotors are required.";
                }
                if (closed) {
                    keyRotors = keyRotors.concat([keyRotors[0]]);
                }
                return _canonicalized(keyRotors);
            };

            const _check_keyTimes = (keyTimes, n_quaternions) => {
                if (typeof (keyTimes) === "undefined") {
                    return seq_len(n_quaternions);
                }
                if (n_quaternions != keyTimes.length) {
                    throw "Numbers of key times and key rotors do not match.";
                }
                let i = 1;
                while (i < keyTimes.length) {
                    if (keyTimes[i] <= keyTimes[i - 1]) {
                        throw "`keyTimes` must be an increasing vector of numbers.";
                    }
                    i += 1;
                }
                return keyTimes;
            };

            KochanekBartels = (keyRotors, keyTimes, tcb) => {
                keyRotors = keyRotors.map(function (q) { return q.clone(); });
                keyRotors = _check_keyRotors(keyRotors, true);
                const n_keyRotors = keyRotors.length;
                keyTimes = _check_keyTimes(keyTimes, n_keyRotors)
                const triples = _check_endcondition("closed", keyRotors, keyTimes);
                const triples_rotors = triples["rotors"];
                const triples_times = triples["times"];
                let control_points = new Array(4 * triples_rotors.length);
                for (let i = 0; i < triples_rotors.length; i++) {
                    const qs = triples_rotors[i];
                    const qb_qa = _calculate_control_quaternions(qs, triples_times[i], tcb);
                    const q_before = qb_qa[0];
                    const q_after = qb_qa[1];
                    control_points[4 * i] = q_before;
                    control_points[4 * i + 1] = qs[1];
                    control_points[4 * i + 2] = qs[1];
                    control_points[4 * i + 3] = q_after;
                }
                const n_control_points = control_points.length;
                control_points = control_points.slice(2, n_control_points - 2);
                const k = ~~(control_points.length / 4);
                const indices = new Array(k);
                for (let i = 0; i < k; i++) {
                    indices[i] = 4 * i;
                }
                const segments = indices.map(function (i) { return control_points.slice(i, i + 4); });
                return DeCasteljau(segments, keyTimes);
            };

        }


        function prep() {

            // spherical to Cartesian coordinates
            const sph2cart = (rho, theta, phi) => (
                new THREE.Vector3(
                    rho * Math.cos(theta) * Math.sin(phi),
                    rho * Math.sin(theta) * Math.sin(phi),
                    rho * Math.cos(phi)
                )
            );

            // construction of the key points (red balls) on the sphere
            const redMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            var phi = 1; // polar angle
            for (let i = 0; i < 6; i++) {
                const theta = i * (2 * Math.PI) / 6;
                const keyPoint = sph2cart(rho, theta, phi);
                keyPoints[i] = keyPoint.clone();
                const x = keyPoint.x;
                const y = keyPoint.y;
                const z = keyPoint.z;
                const sphereGeom = new THREE.SphereGeometry(0.25).translate(x, y, z);
                keyBalls[i] = new THREE.Mesh(sphereGeom, redMaterial);
                phi = Math.PI - phi;
            }
            startingPoint = keyPoints[0].clone();

        }


        function init() {

            container1 = document.createElement("div");
            container2 = document.createElement("div");
            container.appendChild(container1);
            container.appendChild(container2);

            // lil-gui controls -------------------------------------------------
            lgcontrols = { 
                rotationSpeed: 0.005,
                tension: 0,
                continuity: 0,
                bias: 0
            };
            let gui = new GUI({ autoplace: false, width: 300 });
            gui.domElement.id = "gui";
            gui.add(lgcontrols, "rotationSpeed").min(0).max(0.05).step(0.005).name("Rotation speed");
            gui.add(lgcontrols, "tension").min(-3).max(3).step(0.2).name("Tension")
                .onFinishChange(function (value) {
                    renderSphericalCurve(value, lgcontrols.continuity, lgcontrols.bias);
                    renderHopfTorus(value, lgcontrols.continuity, lgcontrols.bias);
                });
            gui.add(lgcontrols, "continuity").min(-4).max(4).step(0.5).name("Continuity")
                .onFinishChange(function (value) {
                    renderSphericalCurve(lgcontrols.tension, value, lgcontrols.bias);
                    renderHopfTorus(lgcontrols.tension, value, lgcontrols.bias);
                });
            gui.add(lgcontrols, "bias").min(-2).max(2).step(0.1).name("Bias")
                .onFinishChange(function (value) {
                    renderSphericalCurve(lgcontrols.tension, lgcontrols.continuity, value);
                    renderHopfTorus(lgcontrols.tension, lgcontrols.continuity, value);
                });

            window.addEventListener("resize", onWindowResize);
        }


        function onWindowResize() {

            camera1.aspect = windowHalfX / windowY;
            camera2.aspect = windowHalfX / windowY;
            camera1.updateProjectionMatrix();
            camera2.updateProjectionMatrix();

            renderer1.setSize(windowHalfX, windowY);
            renderer2.setSize(windowHalfX, windowY);

        }


        function init1() {

            scene1 = new THREE.Scene();
            camera1 = new THREE.PerspectiveCamera(75, windowHalfX / windowY, 0.1, 1000);
            camera1.position.z = 15;
            scene1.add(camera1);

            const lights1 = [];
            lights1[0] = new THREE.PointLight(0xffffff, 1, 0);
            lights1[1] = new THREE.PointLight(0xffffff, 1, 0);
            lights1[2] = new THREE.PointLight(0xffffff, 1, 0);
            lights1[0].position.set(0, 200, 0);
            lights1[1].position.set(100, 200, 100);
            lights1[2].position.set(-100, -200, -100);

            scene1.add(lights1[0]);
            scene1.add(lights1[1]);
            scene1.add(lights1[2]);

            object1 = new THREE.Object3D();
            scene1.add(object1);

            renderer1 = new THREE.WebGLRenderer({ antialias: true });
            renderer1.setSize(windowHalfX, windowY);
            container1.appendChild(renderer1.domElement);

            // the sphere (icosahedron)
            const geomIcosahedron = new THREE.IcosahedronGeometry(5, 4);
            const materialIcosahedron = new THREE.MeshPhongMaterial({
                color: 0x156289,
                emissive: 0x072534,
                shininess: 2,
                flatShading: true,
                transparent: 1,
                opacity: 1
            });
            const meshIcosahedron = new THREE.Mesh(geomIcosahedron, materialIcosahedron);
            // edges of the sphere
            const edges = new THREE.EdgesGeometry(geomIcosahedron);
            const lines = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: false,
                    opacity: 1
                })
            );

            object1.add(meshIcosahedron);
            object1.add(lines);

            // add the red key balls
            for (let i = 0; i < keyBalls.length; i++) {
                object1.add(keyBalls[i]);
            }

            // draw the equator
            equator = (rho, t) => (
                new THREE.Vector3(
                    rho * Math.cos(2 * Math.PI * t),
                    rho * Math.sin(2 * Math.PI * t),
                    0
                )
            );
            const equatorMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                linewidth: 3
            });
            const npointsEquator = 100;
            const ptsEquator = new Array(npointsEquator + 1);
            for (let i = 0; i <= npointsEquator; i++) {
                ptsEquator[i] = equator(rho, i / npointsEquator);
            }
            const equatorCurve = new THREE.CatmullRomCurve3(ptsEquator);
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(
                equatorCurve.getPoints(200)
            );
            const equatorCurveObject = new THREE.Line(equatorGeometry, equatorMaterial);
            object1.add(equatorCurveObject);

            // construction of the key rotors; the first key rotor is the identity
            //   quaternion and rotor i sends the key point 1 to the key point i
            const nkeyRotors = 6;
            const keyRotors = new Array(nkeyRotors);
            var rotor = new THREE.Quaternion(0, 0, 0, 1);
            keyRotors[0] = rotor.clone();
            const startingRotor = rotor.clone();
            for (let i = 0; i < nkeyRotors - 1; i++) {
                const point1 = keyPoints[i].clone();
                const point2 = keyPoints[i + 1].clone();
                keyRotors[i + 1] = new THREE.Quaternion()
                    .setFromUnitVectors(point1.divideScalar(rho), point2.divideScalar(rho));
                keyRotors[i + 1].multiply(keyRotors[i]);
            }

            // the times corresponding to the yellow balls on the sphere
            const yellowTimes = new Array(121);
            for (let i = 0; i < 121; i++) {
                yellowTimes[i] = 0.05 * i;
            }

            const Spline = (t, c, b) => {
                const kb = KochanekBartels(keyRotors, seq_len(7), [t, c, b]);
                return kb;
            };

            const YellowPoints = (t, c, b) => {
                const rotors = yellowTimes.map(function (time) { return Spline(t, c, b)(time); });
                rotors.shift();
                const out = Array(rotors.length);
                for (let i = 0; i < rotors.length; i++) {
                    let p = startingPoint.clone();
                    p.applyQuaternion(rotors[i]);
                    out[i] = p;
                }
                return out;
            };

            // spherical curve (yellow points)
            const yellowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            let group = new THREE.Group();
            renderSphericalCurve = (t, c, b) => {
                group.clear();
                const yellowPoints = YellowPoints(t, c, b);
                for (pt of yellowPoints) {
                    const geom = new THREE.SphereGeometry(0.15).translate(pt.x, pt.y, pt.z);
                    group.add(new THREE.Mesh(geom, yellowMaterial));
                }
                object1.add(group);
            };

            renderSphericalCurve(lgcontrols.tension, lgcontrols.continuity, lgcontrols.bias);

            CatmullRom = (t, c, b) => {
                const yellowPoints = YellowPoints(t, c, b);
                return new THREE.CatmullRomCurve3(yellowPoints, true);
            };

        }


        function init2() {

            scene2 = new THREE.Scene();
            camera2 = new THREE.PerspectiveCamera(75, windowHalfX / windowY, 0.1, 1000);
            camera2.position.z = 17;
            scene2.add(camera2);
            object2 = new THREE.Object3D();
            scene2.add(object2);

            const Hopf0 = (u, v, catmull) => {
                // both u and v run from zero to one in Three.js
                const s = u;
                const phi = 2 * Math.PI * v;
                const p = catmull.getPoint(s);
                const p1 = p.x / rho;
                const p2 = p.y / rho;
                const p3 = p.z / rho;
                const cosphi = Math.cos(phi);
                const sinphi = Math.sin(phi);
                const yden = Math.sqrt(2 * (1 + p3));
                const x4 = (1 + p3) * cosphi / yden;
                const x2 = (p1 * sinphi - p2 * cosphi) / yden;
                const x3 = (p1 * cosphi + p2 * sinphi) / yden;
                const x1 = (1 + p3) * sinphi / yden;
                return new THREE.Vector3(2 * x1 / (1 - x4), 2 * x2 / (1 - x4), 2 * x3 / (1 - x4));
            };
            const Hopf = (catmull) => {
                return function f(u, v, vector) {
                    var out = Hopf0(u, v, catmull);
                    vector.set(out.x, out.y, out.z);
                }
            }

            let group2 = new THREE.Group();
            const hopfMaterial = new THREE.MeshNormalMaterial;
            renderHopfTorus = (t, c, b) => {
                group2.clear();
                const catmull = CatmullRom(t, c, b);
                const hopfGeometry = new THREE.ParametricGeometry(Hopf(catmull), 200, 200);
                const hopfMesh = new THREE.Mesh(hopfGeometry, hopfMaterial);
                group2.add(hopfMesh);
                object2.add(group2);
            };

            renderHopfTorus(lgcontrols.tension, lgcontrols.continuity, lgcontrols.bias);

            renderer2 = new THREE.WebGLRenderer({ antialias: true });
            renderer2.setSize(windowHalfX, windowY);
            container2.appendChild(renderer2.domElement);

        }


        const render1 = () => {
            requestAnimationFrame(render1);
            object1.rotation.x += lgcontrols.rotationSpeed;
            object1.rotation.y += lgcontrols.rotationSpeed;
            renderer1.render(scene1, camera1);
        };

        const render2 = () => {
            renderer2.render(scene2, camera2);
            object2.rotation.x += lgcontrols.rotationSpeed;
            object2.rotation.y += lgcontrols.rotationSpeed;
            requestAnimationFrame(render2);
        };

        const dragging = () => {
            let isDragging1 = false;
            let previousMousePosition1 = { x: 0, y: 0 };
            renderer1.domElement
                .onmousedown = function (e) {
                    isDragging1 = true;
                }
            renderer1.domElement.onmousemove = function (e) {
                    let deltaMove = {
                        x: e.offsetX - previousMousePosition1.x,
                        y: e.offsetY - previousMousePosition1.y
                    };
                    if (isDragging1) {
                        let deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
                            new THREE.Euler(
                                (Math.PI / 180) * (deltaMove.y * 1),
                                (Math.PI / 180) * (deltaMove.x * 1),
                                0,
                                "XYZ"
                            )
                        );
                        object1.quaternion.multiplyQuaternions(
                            deltaRotationQuaternion,
                            object1.quaternion
                        );
                    }
                    previousMousePosition1 = {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                };
            let isDragging2 = false;
            let previousMousePosition2 = { x: 0, y: 0 };
            renderer2.domElement
                .onmousedown = function (e) {
                    isDragging2 = true;
                };
            renderer2.domElement.onmousemove = function (e) {
                    let deltaMove = {
                        x: e.offsetX - previousMousePosition2.x,
                        y: e.offsetY - previousMousePosition2.y
                    };
                    if (isDragging2) {
                        var deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(
                            new THREE.Euler(
                                (Math.PI / 180) * (deltaMove.y * 1),
                                (Math.PI / 180) * (deltaMove.x * 1),
                                0,
                                "XYZ"
                            )
                        );
                        object2.quaternion.multiplyQuaternions(
                            deltaRotationQuaternion,
                            object2.quaternion
                        );
                    }
                    previousMousePosition2 = {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                };

            document.addEventListener("mouseup", function (e) {
                isDragging1 = false;
                isDragging2 = false;
            });

        };

        render1();
        render2();
        dragging();

    </script>
</body>

</html>