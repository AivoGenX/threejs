<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - SDF Geometry</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		*{
			outline: none !important;
		}
		
		textarea, textarea:focus {
			display: none;
		}

	</style>
</head>

<body>
	<!-- Example SDF from https://www.shadertoy.com/view/MdXSWn -->
	<textarea id="mandelbrot">
		float dist(vec3 p) {
			p.xyz = p.xzy;
			p *= 1.2;
			vec3 z = p;
			vec3 dz=vec3(0.0);
			float power = 8.0;
			float r, theta, phi;
			float dr = 1.0;
			
			float t0 = 1.0;
			for(int i = 0; i < 7; ++i) {
				r = length(z);
				if(r > 2.0) continue;
				theta = atan(z.y / z.x);
				#ifdef phase_shift_on
				phi = asin(z.z / r) ;
				#else
				phi = asin(z.z / r);
				#endif
				
				dr = pow(r, power - 1.0) * dr * power + 1.0;
			
				r = pow(r, power);
				theta = theta * power;
				phi = phi * power;
				
				z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;
				
				t0 = min(t0, r);
			}

			return 0.5 * log(r) * r / dr;
		}
	</textarea>

	<!-- Example SDF from https://www.shadertoy.com/view/wlf3WX -->
	<textarea id="head">
		/*
		Head
		----

		This was painstakingly hand modeled by 'tracing' a polygonal model
		exported from Daz 3D.

		The initial approach is to smooth blend small ellipses with a large
		blend radius, a technique I took from Ink Drawing by lnae
		(https://www.shadertoy.com/view/MltcDB)

		The brow and jawline are formed by blending planes and spheres.
		The nose is, of course, a few capsules.
		The ears are various extruded and warped 2D layers, they were by
		far the hardest part.

		I encourage you to comment parts out and see how it all adds up.

		Uses a few primitives and tools from HG_SDF and IQ.

		Apologies for the boring shading, you can see some more interesting
		applications in the GIF and 4K that this was created for:

		* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif
		* ᴇ s ᴄ ʜ ᴇ ʀ ᴡ ᴀ ᴠ ᴇ https://www.shadertoy.com/view/wtf3RM


		License: Creative Commons Attribution-NonCommercial
		https://creativecommons.org/licenses/by-nc/4.0/

		*/

		#define PI 3.14159265359

		void pR(inout vec2 p, float a) {
			p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
		}

		vec2 pRi(vec2 p, float a) {
			pR(p, a);
			return p;
		}

		#define saturate(x) clamp(x, 0., 1.)

		float vmax(vec2 v) {
			return max(v.x, v.y);
		}

		float vmax(vec3 v) {
			return max(max(v.x, v.y), v.z);
		}

		float vmin(vec3 v) {
			return min(min(v.x, v.y), v.z);
		}

		float vmin(vec2 v) {
			return min(v.x, v.y);
		}

		float fBox(vec3 p, vec3 b) {
			vec3 d = abs(p) - b;
			return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
		}

		float fCorner2(vec2 p) {
			return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));
		}

		float fDisc(vec3 p, float r) {
			float l = length(p.xz) - r;
			return l < 0. ? abs(p.y) : length(vec2(p.y, l));
		}

		// IQ https://www.shadertoy.com/view/Xds3zN
		float sdRoundCone( in vec3 p, in float r1, float r2, float h )
		{
			vec2 q = vec2( length(p.xz), p.y );
			
			float b = (r1-r2)/h;
			float a = sqrt(1.0-b*b);
			float k = dot(q,vec2(-b,a));
			
			if( k < 0.0 ) return length(q) - r1;
			if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
				
			return dot(q, vec2(a,b) ) - r1;
		}

		float smin2(float a, float b, float r) {
			vec2 u = max(vec2(r - a,r - b), vec2(0));
			return max(r, min (a, b)) - length(u);
		}

		float smax2(float a, float b, float r) {
			vec2 u = max(vec2(r + a,r + b), vec2(0));
			return min(-r, max (a, b)) + length(u);
		}

		float smin(float a, float b, float k){
			float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);
			return (1. - f) * a + f  * b - f * (1. - f) * k;
		}

		float smax(float a, float b, float k) {
			return -smin(-a, -b, k);
		}

		float smin3(float a, float b, float k){
			return min(
				smin(a, b, k),
				smin2(a, b, k)
			);
		}

		float smax3(float a, float b, float k){
			return max(
				smax(a, b, k),
				smax2(a, b, k)
			);
		}


		float ellip(vec3 p, vec3 s) {
			float r = vmin(s);
			p *= r / s;
			return length(p) - r;
		}

		float ellip(vec2 p, vec2 s) {
			float r = vmin(s);
			p *= r / s;
			return length(p) - r;
		}

		bool isEye = false;


		float dist(vec3 p) {
			p *= 0.75;
			pR(p.yz, -.1);
			p.y -= .11;

			vec3 pa = p;
			vec3 ps = p;
			ps.x = sqrt(ps.x * ps.x + .0005);
			p.x = abs(p.x);
			vec3 pp = p;

			float d = 1e12;

			// skull back
			p += vec3(0,-.135,.09);
			d = ellip(p, vec3(.395, .385, .395));

			// skull base
			p = pp;
			p += vec3(0,-.135,.09) + vec3(0,.1,.07);
			d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);

			// forehead
			p = pp;
			p += vec3(0,-.145,-.175);
			d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);

			p = pp;
			pR(p.yz, -.5);
			float bb = fBox(p, vec3(.5,.67,.7));
			d = smax(d, bb, .2);

			// face base
			p = pp;
			p += vec3(0,.25,-.13);
			d = smin(d, length(p) - .28, .1);

			// behind ear
			p = ps;
			p += vec3(-.15,.13,.06);
			d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);

			p = ps;
			p += vec3(-.07,.18,.1);
			d = smin(d, length(p) - .2, .18);

			// cheek base
			p = pp;
			p += vec3(-.2,.12,-.14);
			d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);

			// jaw base
			p = pp;
			p += vec3(0,.475,-.16);
			pR(p.yz, .8);
			d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);
			
			// brow
			p = pp;
			p += vec3(0,-.0,-.18);
			vec3 bp = p;
			float brow = length(p) - .36;
			p.x -= .37;
			brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);
			p = bp;
			brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);
			p = bp;
			pR(p.yz, -.5);
			float peak = -p.y - .165;
			peak += smoothstep(.0, .2, p.x) * .01;
			peak -= smoothstep(.12, .29, p.x) * .025;
			brow = smax(brow, peak, .07);
			p = bp;
			pR(p.yz, .5);
			brow = smax(brow, -p.y - .06, .15);
			d = smin(d, brow, .06);

			// jaw

			vec3 jo = vec3(-.25,.4,-.07);
			p = ps + jo;
			float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;
			jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);
			jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);
			jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);
			jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);
			jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);
			jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);

			p = pp;
			p += vec3(0,.63,-.2);
			pR(p.yz, .15);
			float cr = .5;
			jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);

			p = pp + jo;
			jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);
			jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);
			jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);

			p = pa;
			p += vec3(.2,.5,-.1);
			float jb = length(p);
			jb = smoothstep(.0, .4, jb);
			float js = mix(0., -.005, jb);
			jb = mix(.01, .04, jb);

			d = smin(d, jaw - js, jb);

			// chin
			p = pp;
			p += vec3(0,.585,-.395);
			p.x *= .7;
			d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);

			// nose
			p = pp;
			p += vec3(0,.03,-.45);
			pR(p.yz, 3.);
			d = smin(d, sdRoundCone(p, .008, .05, .18), .1);

			p = pp;
			p += vec3(0,.06,-.47);
			pR(p.yz, 2.77);
			d = smin(d, sdRoundCone(p, .005, .04, .225), .05);

			// cheek

			p = pp;
			p += vec3(-.2,.2,-.28);
			pR(p.xz, .5);
			pR(p.yz, .4);
			float ch = ellip(p, vec3(.1,.1,.12)*1.05);
			d = smin(d, ch, .1);

			p = pp;
			p += vec3(-.26,.02,-.1);
			pR(p.xz, .13);
			pR(p.yz, .5);
			float temple = ellip(p, vec3(.1,.1,.15));
			temple = smax(temple, p.x - .07, .1);
			d = smin(d, temple, .1);

			p = pp;
			p += vec3(.0,.2,-.32);
			ch = ellip(p, vec3(.1,.08,.1));
			d = smin(d, ch, .1);

			p = pp;
			p += vec3(-.17,.31,-.17);
			ch = ellip(p, vec3(.1));
			d = smin(d, ch, .1);

			// mouth base
			p = pp;
			p += vec3(-.0,.29,-.29);
			pR(p.yz, -.3);
			d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);

			p = pp;
			p += vec3(0,.37,-.4);
			d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);

			p = pp;
			p += vec3(-.09,.37,-.31);
			d = smin(d, ellip(p, vec3(.04)), .18);

			// bottom lip
			p = pp;
			p += vec3(0,.455,-.455);
			p.z += smoothstep(.0, .2, p.x) * .05;
			float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));
			vec3 ls = vec3(.055,.028,.022) * 1.25;
			float w = .192;
			vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));
			float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;
			bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);
			d = smin(d, bottomlip, lb);
			
			// top lip
			p = pp;
			p += vec3(0,.38,-.45);
			pR(p.xz, -.3);
			ls = vec3(.065,.03,.05);
			w = ls.x * (-log(ls.y/ls.x) + 1.);
			vec3 pl = p * vec3(.78,1,1);
			float toplip = length(pl + vec3(0,w-ls.y,0)) - w;
			toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);
			p = pp;
			p += vec3(0,.33,-.45);
			pR(p.yz, .7);
			float cut;
			cut = dot(p, normalize(vec3(.5,.25,0))) - .056;
			float dip = smin(
				dot(p, normalize(vec3(-.5,.5,0))) + .005,
				dot(p, normalize(vec3(.5,.5,0))) + .005,
				.025
			);
			cut = smax(cut, dip, .04);
			cut = smax(cut, p.x - .1, .05);
			toplip = smax(toplip, cut, .02);

			d = smin(d, toplip, .07);

			// seam
			p = pp;
			p += vec3(0,.425,-.44);
			lb = length(p);
			float lr = mix(.04, .02, smoothstep(.05, .12, lb));
			pR(p.yz, .1);
			p.y -= smoothstep(0., .03, p.x) * .002;
			p.y += smoothstep(.03, .1, p.x) * .007;
			p.z -= .133;
			float seam = fDisc(p, .2);
			seam = smax(seam, -d - .015, .01); // fix inside shape
			d = mix(d, smax(d, -seam, lr), .65);

			// nostrils base
			p = pp;
			p += vec3(0,.3,-.43);
			d = smin(d, length(p) - .05, .07);

			// nostrils
			p = pp;
			p += vec3(0,.27,-.52);
			pR(p.yz, .2);
			float nostrils = ellip(p, vec3(.055,.05,.06));

			p = pp;
			p += vec3(-.043,.28,-.48);
			pR(p.xy, .15);
			p.z *= .8;
			nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);

			d = smin(d, nostrils, .02);

			p = pp;
			p += vec3(-.033,.3,-.515);
			pR(p.xz, .5);
			d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);

			//return d;

			// eyelids
			p = pp;
			p += vec3(-.16,.07,-.34);
			float eyelids = ellip(p, vec3(.08,.1,.1));

			p = pp;
			p += vec3(-.16,.09,-.35);
			float eyelids2 = ellip(p, vec3(.09,.1,.07));

			// edge top
			p = pp;
			p += vec3(-.173,.148,-.43);
			p.x *= .97;
			float et = length(p.xy) - .09;

			// edge bottom
			p = pp;
			p += vec3(-.168,.105,-.43);
			p.x *= .9;
			float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;
			eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);
			eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);

			float edge = max(max(eb, et), -d);

			d = smin(d, eyelids, .01);
			d = smin(d, eyelids2, .03);
			d = smax(d, -edge, .005);

			// eyeball
			p = pp;
			p += vec3(-.165,.0715,-.346);
			float eyeball = length(p) - .088;
			isEye = eyeball < d;
			d = min(d, eyeball);

			// tear duct
			p = pp;
			p += vec3(-.075,.1,-.37);
			d = min(d, length(p) - .05);

			
				// ear
			p = pp;
			p += vec3(-.405,.12,.10);
			pR(p.xy, -.12);
			pR(p.xz, .35);
			pR(p.yz, -.3);
			vec3 pe = p;

			// base
			float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;
			float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));

			// inner
			pR(p.xz, -.5);
			float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));
			iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);
			float ridge = iear;
			iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);
			ear = smax2(ear, -iear, .04);
			earback = smin(earback, iear - .04, .02);

			// ridge
			p = pe;
			pR(p.xz, .2);
			ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));
			ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);
			ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);

			float ridger = .01;

			ridge = max(-ridge, ridge - ridger);

			ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);

			ear = smin(ear, ridge, .045);

			p = pe;

			// outline
			float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));
			outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);

			// edge
			float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;

			float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));
			edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);
			float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);
			edgeo = smax(edgeo, -edgeoin, .05);

			float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));
			eedent += smoothstep(.1, -.1, -p.z) * .2;
			eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;
			eedent = min(eedent, 1.);

			eedge += eedent * .06;

			eedge = smax(eedge, -edgeo, .01);
			ear = smin(ear, eedge, .01);
			ear = max(ear, earback);

			ear = smax2(ear, outline, .015);

			d = smin(d, ear, .015);

			// targus
			p = pp;
			p += vec3(-.34,.2,.02);
			d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);
			p = pp;
			p += vec3(-.37,.18,.03);
			pR(p.xz, .5);
			pR(p.yz, -.4);
			d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);
			
			return d;
		}
	</textarea>

	<!-- Example SDF from https://www.shadertoy.com/view/3lGcWt -->
	<textarea id="suzanne">
		void pR(inout vec2 p, float a) {
			p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
		}

		float dist(vec3 p) {
			pR(p.yx, 3.14 * 0.5);
			pR(p.xz, 3.14 * 0.5);
			p *= 0.8;
			// early skip if outside
			if (length(p) > 3.0) {
				return length(p)-2.8;
			}
			//neural networks can be really compact... when they want to be
			vec4 f0_0=sin(p.y*vec4(.00,.00,.00,.01)+p.z*vec4(1.20,-.11,-.05,-3.66)+p.x*vec4(-2.55,.14,-4.41,-.07)+vec4(-3.04,-3.15,-1.75,-4.00));
			vec4 f0_1=sin(p.y*vec4(-.00,-.00,-2.96,-.00)+p.z*vec4(2.84,-.30,-1.07,-2.13)+p.x*vec4(.10,-.38,-.75,-.36)+vec4(-.49,3.12,1.50,3.14));
			vec4 f0_2=sin(p.y*vec4(2.96,.00,-.00,.00)+p.z*vec4(-1.08,.00,-1.10,-.47)+p.x*vec4(-.76,.00,1.15,-.15)+vec4(-4.79,-1.57,-2.81,-3.25));
			vec4 f0_3=sin(p.y*vec4(-.00,-.01,.00,.00)+p.z*vec4(2.89,3.26,2.06,.47)+p.x*vec4(2.78,3.55,-2.21,-3.80)+vec4(4.83,2.15,1.87,-2.77));
			vec4 f1_0=sin(mat4(.10,3.36,-1.58,.75,.19,1.62,-.59,.23,-.26,.84,-.26,-.33,-.21,-.13,.07,-.32)*f0_0+
				mat4(-.46,-2.33,.84,-.20,-1.29,-1.43,.93,-1.44,-.62,-.91,-.46,-1.05,-.21,1.57,1.21,.60)*f0_1+
				mat4(-.62,-.92,-.45,-1.06,.03,.19,.10,-.54,.08,-.27,-.26,-.05,-.22,.86,-.40,-.02)*f0_2+
				mat4(-.22,.02,.20,.08,.56,.05,-.24,.70,.46,.51,1.51,.98,-.82,-1.18,.37,-.84)*f0_3+
				vec4(.72,.15,-1.14,2.07))/1.0+f0_0;
			vec4 f1_1=sin(mat4(-.64,1.09,-.42,.08,.85,.28,-.17,-.14,-1.07,-.40,-.00,.02,-.44,-.54,-.36,.03)*f0_0+
				mat4(1.26,.21,-.40,.05,-1.70,-2.36,.13,-.00,.45,.33,.33,1.92,-.74,.09,-.65,-.11)*f0_1+
				mat4(.46,.32,.32,-1.91,-.25,-.29,.51,.31,.68,.20,-1.91,.07,.91,.19,-.16,.17)*f0_2+
				mat4(-1.12,.16,1.30,-.02,-.59,.43,1.29,.00,.07,-.20,-.06,.01,1.29,-.03,-.25,-.05)*f0_3+
				vec4(-.84,-.53,2.27,-1.30))/1.0+f0_1;
			vec4 f1_2=sin(mat4(.26,.07,-.40,.47,.04,.38,.43,.50,.05,.64,.33,.13,-.20,.26,-.10,.70)*f0_0+
				mat4(1.03,.15,.12,-.31,-.39,-.69,-1.47,-1.35,-.88,-.27,1.67,1.13,-.16,-.16,.49,-1.24)*f0_1+
				mat4(-.88,-.30,1.66,1.14,-.58,-.57,-.15,.38,-1.43,.23,-.05,-.47,-.54,.18,.16,.43)*f0_2+
				mat4(-.78,.92,.32,-.52,-.74,.53,.43,-.35,1.08,-.74,-.26,-1.09,.64,-.39,.15,.62)*f0_3+
				vec4(2.06,2.87,.46,-1.97))/1.0+f0_2;
			vec4 f1_3=sin(mat4(-.32,-1.03,.15,.20,-.19,-.88,.04,-.05,-.44,-.43,1.02,.10,-.02,.17,-.07,-.33)*f0_0+
				mat4(.06,2.45,-.25,-.22,-.01,-.53,-.12,-.22,.28,.87,-.06,.50,.60,-2.04,-.66,.09)*f0_1+
				mat4(.29,.85,-.06,.50,.07,-.59,-.61,-.33,-.84,-.81,-.56,.47,-.06,-.17,.42,-.32)*f0_2+
				mat4(-.77,1.29,.42,-.11,-.69,.91,-.05,.14,-.01,-.41,-1.55,.52,1.10,-.05,-.21,.27)*f0_3+
				vec4(1.25,2.26,3.59,1.23))/1.0+f0_3;
			vec4 f2_0=sin(mat4(-.37,1.93,1.64,-.27,-.75,-.24,-.37,-.18,1.51,-1.23,1.02,.27,-.83,.14,.57,.20)*f1_0+
				mat4(1.66,.53,.54,.55,.37,-3.52,1.62,1.72,-.07,-.29,.15,.23,-.21,1.43,-.13,.21)*f1_1+
				mat4(-.02,-.52,.14,.25,-.59,1.12,-.75,-.14,-.58,-.34,-.62,.31,-.58,1.11,.92,-.04)*f1_2+
				mat4(-.17,-1.10,.31,-.94,-.96,.35,-.06,-.12,.38,-1.48,1.04,.27,-.47,1.09,-1.76,1.23)*f1_3+
				vec4(.78,-1.51,-1.70,-.30))/1.4+f1_0;
			vec4 f2_1=sin(mat4(1.92,-1.36,.28,1.21,.56,.98,-.21,-.71,.89,-.41,.31,1.48,.47,.09,-.72,-.13)*f1_0+
				mat4(-.40,-.59,.50,1.09,-.88,.45,.23,-.72,-.09,-.26,-.04,.54,.47,-.20,.02,-.45)*f1_1+
				mat4(-.21,-.27,-.06,.52,2.09,1.19,.96,.36,-.26,.02,.38,-.69,.42,-.43,-.72,.01)*f1_2+
				mat4(2.63,.06,-.27,1.52,.53,.47,.07,.11,-.55,-.86,.10,.00,.07,1.05,.50,-.32)*f1_3+
				vec4(-2.37,5.12,-1.09,-2.25))/1.4+f1_1;
			vec4 f2_2=sin(mat4(.81,-.14,1.10,.17,.12,-.24,.31,-.08,.81,-.35,-.47,.16,.18,-.27,-.46,.32)*f1_0+
				mat4(.27,.19,-.66,.24,.74,-.93,-2.85,.28,.11,.15,.26,.86,.32,-.02,.07,.01)*f1_1+
				mat4(.08,.15,.21,.86,.69,.03,.11,.35,.01,-.31,-.80,-1.88,-.62,.30,.73,1.16)*f1_2+
				mat4(.76,-.16,1.54,1.22,.13,.27,1.36,.66,-.33,-.12,-.83,-.93,1.23,.06,.11,-1.64)*f1_3+
				vec4(-2.71,-1.53,.42,-.07))/1.4+f1_2;
			vec4 f2_3=sin(mat4(-.16,-1.51,-.23,-.90,-.11,-.62,-.74,.63,1.37,-.79,.58,-.96,-.41,-.16,.00,.56)*f1_0+
				mat4(-.18,.35,.01,-1.15,.07,1.33,1.03,1.26,.18,.63,.29,-.81,.61,.39,-.66,.70)*f1_1+
				mat4(.12,.60,.35,-.86,.21,-.86,.17,-.52,-.03,.47,-.53,.57,-1.34,.21,1.09,-.35)*f1_2+
				mat4(.56,-2.60,.27,-.68,.56,-1.01,-.05,.31,-.34,.71,-.07,-.36,-.32,1.49,-1.82,1.04)*f1_3+
				vec4(-.41,.70,-.56,-1.46))/1.4+f1_3;
			float d = dot(f2_0,vec4(.02,-.01,-.02,-.06))+
				dot(f2_1,vec4(-.02,-.04,-.07,-.03))+
				dot(f2_2,vec4(-.06,-.16,.03,.02))+
				dot(f2_3,vec4(.06,-.03,-.04,.03))+
				0.040;
			// limit to inside unit sphere as neural sdf is not really defined
			return max(d,length(p)-1.);
		}
	</textarea>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -SDF to Mesh-<br/>
		a wrapper of <a href="https://www.npmjs.com/package/isosurface" target="_blank" > Mikola Lysenko's Isosurface</a><br/>
		Mandelbrot by <a href="https://www.shadertoy.com/view/MdXSWn" target="_blank" > EvilRyu</a><br/>
		Head by <a href="https://www.shadertoy.com/view/wlf3WX" target="_blank" > tdhooper</a><br/>
		Suzanne by <a href="https://www.shadertoy.com/view/3lGcWt" target="_blank" > NuSan</a> ( w/ Blackie's Neural SDF )
	</div>
	
	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>
	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { SDFGeometryGenerator } from 'three/addons/geometries/SDFGeometryGenerator.js';
		
		let renderer, stats, meshFromSDF, scene, camera, clock, controls;

		const settings = {
			type: 'mandelbrot',
			res: 4,
			bounds: 1,
			autoRotate: true,
			wireframe: true,
			material: 'depth',
			vertexCount: '0'
		};

		init();
		animate();

		function init() {

			const w = window.innerWidth;
			const h = window.innerHeight;

			camera = new THREE.OrthographicCamera( w / - 2, w / 2, h / 2, h / - 2, 0.01, 1600 );
			camera.position.z = 1100;

			scene = new THREE.Scene();
		
			clock = new THREE.Clock();

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			stats = new Stats();
			document.body.appendChild( stats.dom );

			controls = new OrbitControls( camera, renderer.domElement );
			controls.enableDamping = true;

			window.addEventListener( 'resize', onWindowResize );

			//
		
			const panel = new GUI( );
			panel.add( settings, 'type', [ 'mandelbrot', 'head', 'suzanne' ] ).name( 'Type' ).onChange( compile );
			panel.add( settings, 'res', 1, 6, 1 ).name( 'Res' ).onFinishChange( compile );
			panel.add( settings, 'bounds', 1, 10, 1 ).name( 'Bounds' ).onFinishChange( compile );
			panel.add( settings, 'material', [ 'depth', 'normal' ] ).name( 'Material' ).onChange( setMaterial );
			panel.add( settings, 'wireframe' ).name( 'Wireframe' ).onChange( setMaterial );
			panel.add( settings, 'autoRotate' ).name( 'Auto Rotate' );
			panel.add( settings, 'vertexCount' ).name( 'Vertex count' ).listen().disable();

			//

			compile();

		}

		function compile() {
		
			const generator = new SDFGeometryGenerator( renderer );
			const geometry = generator.generate( Math.pow( 2, settings.res + 2 ), document.querySelector( 'textarea#' + settings.type ).value, settings.bounds );
			geometry.computeVertexNormals();

			if ( meshFromSDF ) { // updates mesh

				meshFromSDF.geometry = geometry;
		
			} else { // inits meshFromSDF : THREE.Mesh
		
				meshFromSDF = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial() );
				scene.add( meshFromSDF );
		
				const scale = Math.min( window.innerWidth, window.innerHeight ) / 2 * 0.66;
				meshFromSDF.scale.set( scale, scale, scale );
		
				setMaterial();
		
			}

			settings.vertexCount = geometry.attributes.position.count;

		}

		function setMaterial() {

			if ( settings.material == 'depth' ) {

				meshFromSDF.material = new THREE.MeshDepthMaterial();
		
			} else if ( settings.material == 'normal' ) {

				meshFromSDF.material = new THREE.MeshNormalMaterial();
		
			}

			meshFromSDF.material.wireframe = settings.wireframe;

		}

		function onWindowResize() {

			const w = window.innerWidth;
			const h = window.innerHeight;

			renderer.setSize( w, h );

			camera.left = w / - 2;
			camera.right = w / 2;
			camera.top = h / 2;
			camera.bottom = h / - 2;

			camera.updateProjectionMatrix();

		}

		function render() {

			renderer.render( scene, camera );

		}

		function animate() {

			requestAnimationFrame( animate );

			controls.update();

			if ( settings.autoRotate ) {

				meshFromSDF.rotation.y += Math.PI * 0.05 * clock.getDelta();

			}

			render();

			stats.update();

		}

	</script>

</body>
</html>
