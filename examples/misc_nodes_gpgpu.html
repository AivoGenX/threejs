<html lang="en">
	<head>
		<title>three.js - Nodes - GPGPU</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> Nodes - GPGPU
		</div>

		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { ShaderNode, color, remainder, add, sub, mul, uint, bitXor, shiftRight, vec4, uvec4, storage, element, compute, instanceIndex } from 'three/nodes';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

			import { nodeFrame } from 'three/addons/renderers/webgl/nodes/WebGLNodes.js';

			import { getTextureType, getTextureFormat, calculateWidthHeight } from 'three/addons/renderers/webgl/WebGLBuffer.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const params = {

				backend: 'WebGL',
				example: 'Multiplication',
				warmUps: 2,
				logBuffers: false,
				logPerformance: true,
				refresh: false,
				clearConsole: false

			};

			const hash = new ShaderNode( ( { num }, stack ) => { // Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org

				const state = add( mul( uint( num ), 747796405 ), 2891336453 );
				const word = mul( bitXor( shiftRight( state, add( shiftRight( state, 28 ), 4 ) ), state ), 277803737 );
				const uintResult = bitXor( shiftRight( word, 22 ), word );

				return mul( 1 / 2 ** 32, uintResult ); // Convert to range [0, 1)

			} );

			let camera, scene, material, renderer, computationRenderer, iterations;

			init();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 0, 2 );

				scene = new THREE.Scene();

				material = new THREE.MeshBasicMaterial();
				const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( mesh );

				window.addEventListener( 'resize', onWindowResize );

				// gui

				const gui = new GUI();

				gui.add( params, 'backend', [ 'WebGL', 'WebGPU' ] ).onChange( () => { setBackend().then( showExample ); } );
				gui.add( params, 'example', [ 'Passthrough', 'AntiPassthrough', 'PassthroughColor', 'ElementManipulation', 'Multiplication', 'Random' ] ).onChange( showExample );
				gui.add( params, 'warmUps', 0, 5, 1 );
				gui.add( params, 'logBuffers' );
				gui.add( params, 'logPerformance' );
				gui.add( params, 'refresh' ).onChange( () => { params.refresh = false; setBackend().then( showExample ); } );
				gui.add( params, 'clearConsole' ).onChange( () => { params.clearConsole = false; console.clear(); } );

				setBackend();
				showExample();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function disposeRenderer( renderer ) {

				if ( material.map !== null ) {

					material.map.dispose(); // Texture should be disposed before disposing the renderer
					material.map = null;

				}

				if ( renderer !== undefined ) {

					renderer.domElement.remove();
					renderer.dispose();

				}

			}

			async function setBackend() {

				const oldRenderer = renderer;

				document.getElementById( 'webgpumessage' )?.remove();

				if ( params.backend === 'WebGPU' && WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					disposeRenderer( oldRenderer );

					throw new Error( 'No WebGPU support' );

				}

				if ( params.backend === 'WebGL' ) {

					renderer = new THREE.WebGLRenderer();

				} else {

					renderer = new WebGPURenderer();
					await renderer.init();

				}

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				disposeRenderer( oldRenderer );

				iterations = {};

			}

			async function showExample() {

				if ( iterations[ params.example ] === undefined ) iterations[ params.example ] = 0;
				const iteration = iterations[ params.example ];
				iterations[ params.example ] ++;

				if ( params.logPerformance ) console.time( params.backend + ' ' + params.example + ' Iteration-' + iteration );

				if ( material.map !== null ) {

					material.map.dispose();
					material.map = null;

				}

				let shaderNode, outAttribute;

				const TypedArray = params.backend === 'WebGL' ? Uint8Array : Uint32Array; // WebGPU can only work with uint32

				const index = instanceIndex; // @COMMENT: Maybe make this an alias to instanceIndex in ShaderNodeBaseElements?

				switch ( params.example ) {

					case 'Passthrough':
						outAttribute = new THREE.BufferAttribute( new TypedArray( 256 ), 1 );
						shaderNode = new ShaderNode( ( {}, stack ) => stack.assign( element( storage( outAttribute ), index ), index ) );
						break;

					case 'AntiPassthrough':
						outAttribute = new THREE.BufferAttribute( new TypedArray( 256 ), 1 );
						shaderNode = new ShaderNode( ( {}, stack ) => stack.assign( element( storage( outAttribute ), index ), sub( 255, index ) ) );
						break;

					case 'PassthroughColor':
						outAttribute = new THREE.BufferAttribute( new TypedArray( 256 * 4 ), 4 );
						shaderNode = new ShaderNode( ( {}, stack ) => stack.assign( element( storage( outAttribute ), index ), params.backend === 'WebGL' ? index : uvec4( index, index, index, uint( 255 ) ) ) );
						break;

					case 'ElementManipulation':
						const srcAttribute = new THREE.BufferAttribute( new TypedArray( 256 ), 1 );
						srcAttribute.array[ 0 ] = 255;
						srcAttribute.array[ 7 ] = 192 - 7;
						srcAttribute.array[ 8 ] = 64 - 8;
						srcAttribute.array[ 15 ] = 255 - 15;
						const srcBuffer = storage( srcAttribute );
						outAttribute = new THREE.BufferAttribute( new TypedArray( 256 ), 1 );
						shaderNode = new ShaderNode( ( {}, stack ) => stack.assign( element( storage( outAttribute ), index ), add( index, element( srcBuffer, index ) ) ) );
						break;

					case 'Multiplication':
						outAttribute = new THREE.BufferAttribute( new TypedArray( 256 * 4 ), 4 );
						shaderNode = new ShaderNode( ( {}, stack ) => {

							const result = [ remainder( mul( index, 2 ), 256 ), remainder( mul( index, 3 ), 256 ), remainder( mul( index, 5 ), 256 ) ];
							stack.assign( element( storage( outAttribute ), index ), params.backend === 'WebGL' ? color( ...result ) : uvec4( ...result, uint( 255 ) ) );
							return stack;

						} );
						break;

					case 'Random':
						outAttribute = new THREE.BufferAttribute( new TypedArray( 1024 ** 2 * 4 ), 4 );
						shaderNode = new ShaderNode( ( {}, stack ) => {

							const r = hash.call( { num: add( mul( index, 4 ), 0 ) }, stack ); // @TODO: Tweak parameters to some that produce a more random image
							const g = hash.call( { num: add( mul( index, 4 ), 1 ) }, stack );
							const b = hash.call( { num: add( mul( index, 4 ), 2 ) }, stack );
							const a = hash.call( { num: add( mul( index, 4 ), 3 ) }, stack ); // Works only in WebGPU

							stack.assign( element( storage( outAttribute ), index ), mul( vec4( r, g, b, a ), vec4( 256, 256, 256, 256 ) ) );

							return stack;

						} );
						break;

				}

				await renderer.compute( compute( shaderNode, outAttribute.count ) );
				if ( params.backend === 'WebGPU' ) await renderer.populateArray( outAttribute );

				let typedArray = outAttribute.array;

				if ( params.logBuffers && iteration === 0 ) console.log( params.backend, params.example, typedArray );

				if ( params.backend === 'WebGPU' ) typedArray = uint32ToUint8( typedArray ); // WebGPU doesn't currently support sampling uint32 textures

				const type = getTextureType( outAttribute );
				const format = getTextureFormat( outAttribute );
				const { width, height } = calculateWidthHeight( outAttribute.count );

				material.map = new THREE.DataTexture( typedArray, width, height, format, type );
				material.map.needsUpdate = true;

				await renderer.render( scene, camera );

				if ( params.logPerformance ) console.timeEnd( params.backend + ' ' + params.example + ' Iteration-' + iteration );

				if ( iteration < params.warmUps ) await showExample();

			}

			function uint32ToUint8( uint32Array ) {

				const uint8Array = new Uint8Array( uint32Array.length );
				uint32Array.forEach( ( value, index ) => { uint8Array[ index ] = value; } );
				return uint8Array;

			}

		</script>
	</body>
</html>
