<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - LDrawLoader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>

	<body>
		<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - LDrawLoader
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { GUI } from './jsm/libs/lil-gui.module.min.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { RoomEnvironment } from './jsm/environments/RoomEnvironment.js';

			import { LDrawLoader } from './jsm/loaders/LDrawLoader.js';

			import { mergeBufferGeometries } from './jsm/utils/BufferGeometryUtils.js';

			let container, progressBarDiv;

			let camera, scene, renderer, controls, gui, guiData;

			let model;

			const ldrawPath = 'models/ldraw/officialLibrary/';

			const modelFileList = {
				'Car': 'models/car.ldr_Packed.mpd',
				'Lunar Vehicle': 'models/1621-1-LunarMPVVehicle.mpd_Packed.mpd',
				'Radar Truck': 'models/889-1-RadarTruck.mpd_Packed.mpd',
				'Trailer': 'models/4838-1-MiniVehicles.mpd_Packed.mpd',
				'Bulldozer': 'models/4915-1-MiniConstruction.mpd_Packed.mpd',
				'Helicopter': 'models/4918-1-MiniFlyers.mpd_Packed.mpd',
				'Plane': 'models/5935-1-IslandHopper.mpd_Packed.mpd',
				'Lighthouse': 'models/30023-1-Lighthouse.ldr_Packed.mpd',
				'X-Wing mini': 'models/30051-1-X-wingFighter-Mini.mpd_Packed.mpd',
				'AT-ST mini': 'models/30054-1-AT-ST-Mini.mpd_Packed.mpd',
				'AT-AT mini': 'models/4489-1-AT-AT-Mini.mpd_Packed.mpd',
				'Shuttle': 'models/4494-1-Imperial Shuttle-Mini.mpd_Packed.mpd',
				'TIE Interceptor': 'models/6965-1-TIEIntercep_4h4MXk5.mpd_Packed.mpd',
				'Star fighter': 'models/6966-1-JediStarfighter-Mini.mpd_Packed.mpd',
				'X-Wing': 'models/7140-1-X-wingFighter.mpd_Packed.mpd',
				'AT-ST': 'models/10174-1-ImperialAT-ST-UCS.mpd_Packed.mpd'
			};

			init();
			animate();


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 150, 200, 250 );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				container.appendChild( renderer.domElement );

				// scene

				const pmremGenerator = new THREE.PMREMGenerator( renderer );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xdeebed );
				scene.environment = pmremGenerator.fromScene( new RoomEnvironment() ).texture;

				controls = new OrbitControls( camera, renderer.domElement );

				//

				guiData = {
					modelFileName: modelFileList[ 'Car' ],
					displayLines: true,
					conditionalLines: true,
					smoothNormals: true,
					constructionStep: 0,
					noConstructionSteps: 'No steps.',
					flatColors: false,
					mergeModel: false
				};

				window.addEventListener( 'resize', onWindowResize );

				progressBarDiv = document.createElement( 'div' );
				progressBarDiv.innerText = 'Loading...';
				progressBarDiv.style.fontSize = '3em';
				progressBarDiv.style.color = '#888';
				progressBarDiv.style.display = 'block';
				progressBarDiv.style.position = 'absolute';
				progressBarDiv.style.top = '50%';
				progressBarDiv.style.width = '100%';
				progressBarDiv.style.textAlign = 'center';


				// load materials and then the model

				reloadObject( true );

			}

			function updateObjectsVisibility() {

				model.traverse( c => {

					if ( c.isLineSegments ) {

						if ( c.isConditionalLine ) {

							c.visible = guiData.conditionalLines;

						} else {

							c.visible = guiData.displayLines;

						}

					} else if ( c.isGroup ) {

						// Hide objects with construction step > gui setting
						c.visible = c.userData.constructionStep <= guiData.constructionStep;

					}

				} );

			}

			function reloadObject( resetCamera ) {

				if ( model ) {

					scene.remove( model );

				}

				model = null;

				updateProgressBar( 0 );
				showProgressBar();

				// only smooth when not rendering with flat colors to improve processing time
				const lDrawLoader = new LDrawLoader();
				lDrawLoader.smoothNormals = guiData.smoothNormals && ! guiData.flatColors;
				lDrawLoader
					.setPath( ldrawPath )
					.load( guiData.modelFileName, function ( group2 ) {

						if ( model ) {

							scene.remove( model );

						}

						model = group2;

						// demonstrate how to use convert to flat colors to better mimic the lego instructions look
						if ( guiData.flatColors ) {

							function convertMaterial( material ) {

								const newMaterial = new THREE.MeshBasicMaterial();
								newMaterial.color.copy( material.color );
								newMaterial.polygonOffset = material.polygonOffset;
								newMaterial.polygonOffsetUnits = material.polygonOffsetUnits;
								newMaterial.polygonOffsetFactor = material.polygonOffsetFactor;
								newMaterial.opacity = material.opacity;
								newMaterial.transparent = material.transparent;
								newMaterial.depthWrite = material.depthWrite;
								newMaterial.toneMapping = false;

								return newMaterial;

							}

							model.traverse( c => {

								if ( c.isMesh ) {

									if ( Array.isArray( c.material ) ) {

										c.material = c.material.map( convertMaterial );

									} else {

										c.material = convertMaterial( c.material );

									}

								}

							} );

						}

						// Merge model geometries by material
						if ( guiData.mergeModel ) model = mergeObject( model );

						// Convert from LDraw coordinates: rotate 180 degrees around OX
						model.rotation.x = Math.PI;

						scene.add( model );

						guiData.constructionStep = model.userData.numConstructionSteps - 1;

						updateObjectsVisibility();

						// Adjust camera and light

						const bbox = new THREE.Box3().setFromObject( model );
						const size = bbox.getSize( new THREE.Vector3() );
						const radius = Math.max( size.x, Math.max( size.y, size.z ) ) * 0.5;

						if ( resetCamera ) {

							controls.target0.copy( bbox.getCenter( new THREE.Vector3() ) );
							controls.position0.set( - 2.3, 1, 2 ).multiplyScalar( radius ).add( controls.target0 );
							controls.reset();

						}

						createGUI();

						hideProgressBar();

					}, onProgress, onError );

			}

			function mergeObject( object ) {

				// Merges geometries in object by materials and returns new object. Use on not indexed geometries.

				function extractGroup( geometry, group, elementSize, isConditionalLine ) {

					// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)

					const newGeometry = new THREE.BufferGeometry();

					const originalPositions = geometry.getAttribute( 'position' ).array;
					const originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;

					const numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );
					const vertStart = group.start * 3;
					const vertEnd = ( group.start + numVertsGroup ) * 3;

					const positions = originalPositions.subarray( vertStart, vertEnd );
					const normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;

					newGeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
					if ( normals !== null ) newGeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

					if ( isConditionalLine ) {

						const controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );
						const controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );
						const directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );

						newGeometry.setAttribute( 'control0', new THREE.BufferAttribute( controlArray0, 3, false ) );
						newGeometry.setAttribute( 'control1', new THREE.BufferAttribute( controlArray1, 3, false ) );
						newGeometry.setAttribute( 'direction', new THREE.BufferAttribute( directionArray, 3, false ) );

					}

					return newGeometry;

				}

				function addGeometry( mat, geometry, geometries ) {

					const geoms = geometries[ mat.uuid ];
					if ( ! geoms ) {
						geometries[ mat.uuid ] = {
							mat: mat,
							arr: [ geometry ]
						};
					}
					else geoms.arr.push( geometry );

				}

				function permuteAttribute( attribute, elemSize ) {

					// Permutes first two vertices of each attribute element

					if ( ! attribute ) return;

					const verts = attribute.array;
					const numVerts = Math.floor( verts.length / 3 );
					let offset = 0;
					for ( let i = 0; i < numVerts; i ++ ) {

						const x = verts[ offset ];
						const y = verts[ offset + 1 ];
						const z = verts[ offset + 2 ];

						verts[ offset ] = verts[ offset + 3 ];
						verts[ offset + 1 ] = verts[ offset + 4 ];
						verts[ offset + 2 ] = verts[ offset + 5 ];

						verts[ offset + 3 ] = x;
						verts[ offset + 4 ] = y;
						verts[ offset + 5 ] = z;

						offset += elemSize * 3;

					}

				}

				// Traverse the object hierarchy collecting geometries and transforming them to world space

				const meshGeometries = {};
				const linesGeometries = {};
				const condLinesGeometries = {};

				object.updateMatrixWorld( true );
				const normalMatrix = new THREE.Matrix3();

				object.traverse( c => {

					if ( c.isMesh | c.isLineSegments ) {

						const elemSize = c.isMesh ? 3 : 2;

						const matrixIsInverted = c.matrixWorld.determinant() < 0;
						if ( matrixIsInverted ) {

							permuteAttribute( c.geometry.attributes.position, elemSize );
							permuteAttribute( c.geometry.attributes.normal, elemSize );

						}

						c.geometry.applyMatrix4( c.matrixWorld );

						if ( c.isConditionalLine ) {

							if ( matrixIsInverted ) {

								permuteAttribute( c.geometry.attributes.control0, elemSize );
								permuteAttribute( c.geometry.attributes.control1, elemSize );
								permuteAttribute( c.geometry.attributes.direction, elemSize );

							}

							c.geometry.attributes.control0.applyMatrix4( c.matrixWorld );
							c.geometry.attributes.control1.applyMatrix4( c.matrixWorld );
							normalMatrix.getNormalMatrix( c.matrixWorld );
							c.geometry.attributes.direction.applyNormalMatrix( normalMatrix );

						}

						const geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );

						if ( Array.isArray( c.material ) ) {

							for ( const groupIndex in c.geometry.groups ) {

								const group = c.geometry.groups[ groupIndex ];
								const mat = c.material[ group.materialIndex ];
								const newGeometry = extractGroup( c.geometry, group, elemSize, c.isConditionalLine );
								addGeometry( mat, newGeometry, geometries );

							}

						}
						else addGeometry( c.material, c.geometry, geometries );

					}

				} );

				// Create object with merged geometries

				const mergedObject = new THREE.Group();

				const meshMaterialsIds = Object.keys( meshGeometries );
				for ( const i in meshMaterialsIds ) {

					const meshGeometry = meshGeometries[ meshMaterialsIds[ i ] ];
					const mergedGeometry = mergeBufferGeometries( meshGeometry.arr );
					mergedObject.add( new THREE.Mesh( mergedGeometry, meshGeometry.mat ) );

				}

				const linesMaterialsIds = Object.keys( linesGeometries );
				for ( const i in linesMaterialsIds ) {

					const lineGeometry = linesGeometries[ linesMaterialsIds[ i ] ];
					const mergedGeometry = mergeBufferGeometries( lineGeometry.arr );
					mergedObject.add( new THREE.LineSegments( mergedGeometry, lineGeometry.mat ) );

				}

				const condLinesMaterialsIds = Object.keys( condLinesGeometries );
				for ( const i in condLinesMaterialsIds ) {

					const condLineGeometry = condLinesGeometries[ condLinesMaterialsIds[ i ] ];
					const mergedGeometry = mergeBufferGeometries( condLineGeometry.arr );
					mergedObject.add( new THREE.LineSegments( mergedGeometry, condLineGeometry.mat ) );

				}

				mergedObject.userData.constructionStep = 0;
				mergedObject.userData.numConstructionSteps = 1;

				return mergedObject;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function createGUI() {

				if ( gui ) {

					gui.destroy();

				}

				gui = new GUI();

				gui.add( guiData, 'modelFileName', modelFileList ).name( 'Model' ).onFinishChange( function () {

					reloadObject( true );

				} );

				gui.add( guiData, 'flatColors' ).name( 'Flat Colors' ).onChange( function () {

					reloadObject( false );

				} );

				gui.add( guiData, 'mergeModel' ).name( 'Merge model' ).onChange( function () {

					reloadObject( false );

				} );

				if ( model.userData.numConstructionSteps > 1 ) {

					gui.add( guiData, 'constructionStep', 0, model.userData.numConstructionSteps - 1 ).step( 1 ).name( 'Construction step' ).onChange( updateObjectsVisibility );

				} else {

					gui.add( guiData, 'noConstructionSteps' ).name( 'Construction step' ).onChange( updateObjectsVisibility );

				}

				gui.add( guiData, 'smoothNormals' ).name( 'Smooth Normals' ).onChange( function changeNormals() {

					reloadObject( false );

				} );

				gui.add( guiData, 'displayLines' ).name( 'Display Lines' ).onChange( updateObjectsVisibility );

				if ( ! guiData.mergeModel ) {

					gui.add( guiData, 'conditionalLines' ).name( 'Conditional Lines' ).onChange( updateObjectsVisibility );

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

			function onProgress( xhr ) {

				if ( xhr.lengthComputable ) {

					updateProgressBar( xhr.loaded / xhr.total );

					console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );

				}

			}

			function onError() {

				const message = 'Error loading model';
				progressBarDiv.innerText = message;
				console.log( message );

			}

			function showProgressBar() {

				document.body.appendChild( progressBarDiv );

			}

			function hideProgressBar() {

				document.body.removeChild( progressBarDiv );

			}

			function updateProgressBar( fraction ) {

				progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';

			}

		</script>

		<!-- LDraw.org CC BY 2.0 Parts Library attribution -->
		<div style="display: block; position: absolute; bottom: 8px; left: 8px; width: 160px; padding: 10px; background-color: #F3F7F8;">
			<center>
				<a href="http://www.ldraw.org"><img style="width: 145px" src="models/ldraw/ldraw_org_logo/Stamp145.png"></a>
				<br />
				<a href="http://www.ldraw.org/">This software uses the LDraw Parts Library</a>
			</center>
		</div>

	</body>
</html>
