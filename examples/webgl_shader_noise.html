<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - shader [Monjori]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #ffffff;
			}

			#oldie a { color:#da0 }
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - shader demo. featuring <a href="http://www.pouet.net/prod.php?which=52761" target="_blank">Monjori by Mic</a></div>

		<script src="../build/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">
			
			varying vec2 vUv;
			void main()	{
				vUv = uv;
				gl_Position = vec4( position, 1.0 );

			}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			precision lowp float;
  
  uniform vec4 layerAmplitude;
  uniform vec4 layerScale;
  
			uniform float time;
			varying vec2 vUv;

			vec4 permute( vec4 x ) {

    return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );

  }

  vec4 taylorInvSqrt( vec4 r ) {

    return 1.79284291400159 - 0.85373472095314 * r;

  }

  float snoise( vec3 v ) {

    vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );
    const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );

    // First corner

    vec3 i  = floor( v + dot( v, C.yyy ) );
    vec3 x0 = v - i + dot( i, C.xxx );

    // Other corners

    vec3 g = step( x0.yzx, x0.xyz );
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations

    i = mod( i, 289.0 );
    vec4 p = permute( permute( permute(
         i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )
         + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )
         + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );

    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)

    float n_ = 1.0 / 7.0; // N=7

    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)

    vec4 x_ = floor( j * ns.z );
    vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs( x ) - abs( y );

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );


    vec4 s0 = floor( b0 ) * 2.0 + 1.0;
    vec4 s1 = floor( b1 ) * 2.0 + 1.0;
    vec4 sh = -step( h, vec4( 0.0 ) );

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 p0 = vec3( a0.xy, h.x );
    vec3 p1 = vec3( a0.zw, h.y );
    vec3 p2 = vec3( a1.xy, h.z );
    vec3 p3 = vec3( a1.zw, h.w );

    // Normalise gradients

    vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix final noise value

    vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),
                    dot( p2, x2 ), dot( p3, x3 ) ) );

  }

  float surface3( vec3 coord ) {

    float n = 0.0;

    n += layerAmplitude.x * abs( snoise( coord * layerScale.x ) );
//     "n += 0.5 * abs( snoise( coord * 2.0 ) );
//     "n += 0.25 * abs( snoise( coord * 4.0 ) );
//     "n += 0.125 * abs( snoise( coord * 8.0 ) );
    n += layerAmplitude.y * abs( snoise( coord * layerScale.y ) );
    n += layerAmplitude.z * abs( snoise( coord * layerScale.z ) );
    n += layerAmplitude.w * abs( snoise( coord * layerScale.w ) );

    return n;

  }

  void main( void ) {

    vec3 coord = vec3( vUv, -time );
    float n = surface3( coord );

    gl_FragColor = vec4( vec3(n, n, n), 1.0 );

  }

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer;

			var uniforms, material, mesh;

			var mouseX = 0, mouseY = 0,
			lat = 0, lon = 0, phy = 0, theta = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.Camera();
				camera.position.z = 1;

				scene = new THREE.Scene();

				// uniforms = {
				// 	time: { type: "f", value: 1.0 },
				// 	resolution: { type: "v2", value: new THREE.Vector2() }
				// };
				uniforms = {
			    time   : { type : "f", value : 1.0 }, 
			    scale  : { type : "v2", value : new THREE.Vector2(1.0, 1.0) },
			    offset : { type : "v2", value : new THREE.Vector2() },
			    layerAmplitude : { type : "v4", value : new THREE.Vector4(0.75,0.250,0.11, 0.1) },
			    layerScale : { type : "v4", value : new THREE.Vector4(2.0,4.0,10.0,1.0) }
			  };

				material = new THREE.ShaderMaterial( {

					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent

				} );

				mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), material );
				scene.add( mesh );

				renderer = new THREE.WebGLRenderer();
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize( event ) {

				// uniforms.resolution.value.x = window.innerWidth;
				// uniforms.resolution.value.y = window.innerHeight;
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				//uniforms.time.value += 0.05;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
