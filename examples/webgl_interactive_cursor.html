<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - interactive cubes (gpu)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
      }

      .info {
        position: absolute;
        background-color: black;
        opacity: 0.8;
        color: white;
        text-align: center;
        top: 0px;
        width: 100%;
        padding: 10px;
      }

      .info a {
        color: #00ffff;
      }

      .button {
        display: inline-block;
        padding: 8px;
        color: #FFF;
        background-color: #555;
      }

      .button:hover {
        cursor: pointer;
        background-color: red;
      }

      .button.enabled {
        background-color: red;
      }

      .button.error {
        pointer-events: none;
        background-color: red;
      }

      .menu {
        position: fixed;
        bottom: 20px;
        right: 20px;
      }

    </style>
  </head>
  <body>

    <div class="info">
      Click and drag to rotate the camera
    </div>

    <div id="container">
      <div class="menu">
        <div class="button lock-pointer" style="display: none">Lock Pointer</div>
        <div class="button full-screen">Start VR Mode</div>
      </div>
    </div>

    </div>

    <script src="js/libs/bignumber.js"></script>
    <script src="../build/three.js"></script>
    <script src="js/libs/tween.min.js"></script>

    <script src="js/Cursor.js"></script>

    <script src="js/SkyShader.js"></script>
    <script src="js/controls/MouseControls.js"></script>
    <script src="js/effects/VREffect.js"></script>
    <script src="js/controls/VRControls.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <script>

      var container, stats;
      var camera, controls, scene, renderer;
      var objects = [];
      var mouse = new THREE.Vector2();
      var offset = new THREE.Vector3( 10, 10, 10 );
      var cursor;
      var sky;
      var raycaster;
      var INTERSECTED;
      var lockPointerButton = document.querySelector('.lock-pointer');
      var fullScreenButton = document.querySelector( '.full-screen' );
      var vrEffect;
      var vrControls;
      var vrMode;
      var mouseLook = true;

      lockPointerButton.onclick = lockPointer;

      document.exitPointerLock = document.exitPointerLock    ||
                                 document.mozExitPointerLock ||
                                 document.webkitExitPointerLock;

      function lockPointer() {
        var pointerLockElement =
          document.pointerLockElement ||
          document.mozPointerLockElement ||
          document.webkitPointerLockElement;
        if ( !pointerLockElement ) {
          lockPointerButton.textContent = '\'Esc\' to release pointer';
          lockPointerButton.classList.add('enabled');
          renderer.domElement.requestPointerLock();
        }
      }

      function resetPointerLockButton() {
        lockPointerButton.textContent = 'Lock Pointer';
        lockPointerButton.classList.remove('enabled');
      }

      function onPointerLockChanged() {
        var pointerLocked =
        document.pointerLockElement ||
        document.mozPointerLockElement ||
        document.webkitPointerLockElement;

        if ( !pointerLocked ) {
          resetPointerLockButton();
        }
      }

      function onDocumentMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

      }

      document.addEventListener( 'mousemove', onDocumentMouseMove, false );
      document.addEventListener( 'pointerlockchange', onPointerLockChanged, false );
      document.addEventListener( 'mozpointerlockchange', onPointerLockChanged, false );
      document.addEventListener( 'webkitpointerlockchange', onPointerLockChanged, false );

      init();
      animate();

      function init() {

        container = document.getElementById( "container" );

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 2000000 );

        controls = new THREE.MouseControls( camera );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        scene = new THREE.Scene();

        // scene.add( new THREE.AmbientLight( 0x555555 ) );

        var spotLight = new THREE.SpotLight( 0xffffff, 1.5 );
        spotLight.position.set( 1, 1, 10 ).normalize();
        spotLight.shadowMapWidth = 1024;
        spotLight.shadowMapHeight = 1024;
        spotLight.shadowCameraNear = 50;
        spotLight.shadowCameraFar = 4000;
        spotLight.shadowCameraFov = 60;
        spotLight.target = camera;
        camera.add( spotLight );

        var geometry = new THREE.Geometry(),
        defaultMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } );

        function applyVertexColors( g, c ) {

          g.faces.forEach( function( f ) {

            var n = ( f instanceof THREE.Face3 ) ? 3 : 4;

            for( var j = 0; j < n; j ++ ) {

              f.vertexColors[ j ] = c;

            }

          } );

        }

        function explodeBox(box) {

          var duration = 8000;

          // explode geometry into objects
          var pieces = explode( box.geometry, box.material );

          box.material.visible = false;

          // animate objects
          for ( var i = 0; i < pieces.children.length; i ++ ) {

            var object = pieces.children[ i ];

            object.geometry.computeFaceNormals();
            var normal = object.geometry.faces[0].normal.clone();
            var targetPosition = object.position.clone().add( normal.multiplyScalar( 3000 ) );
            removeBoxFromList( box );
            new TWEEN.Tween( object.position )
              .to( targetPosition, duration )
              .onComplete( deleteBox )
              .start();

            object.material.opacity = 0;
            new TWEEN.Tween( object.material )
              .to( { opacity: 1 }, duration )
              .start();

            var rotation = 2 * Math.PI;
            var targetRotation = { x: rotation, y: rotation, z:rotation };
            new TWEEN.Tween( object.rotation )
              .to( targetRotation, duration )
              .start();

          }

          function deleteBox() {
            box.remove( pieces )
            scene.remove( box );
          }

          box.add( pieces )

        }

        function removeBoxFromList( box ) {
          for (var i = 0; i < objects.length; i++) {
            if (objects[i] === box) {
              objects.splice(i, 1);
              return;
            }
          }
        }

        function explode( geometry, material ) {

          var pieces = new THREE.Group();
          var material = material.clone();
          material.side = THREE.DoubleSide;

          for ( var i = 0; i < geometry.faces.length; i ++ ) {

            var face = geometry.faces[ i ];

            var vertexA = geometry.vertices[ face.a ].clone();
            var vertexB = geometry.vertices[ face.b ].clone();
            var vertexC = geometry.vertices[ face.c ].clone();

            var geometry2 = new THREE.Geometry();
            geometry2.vertices.push( vertexA, vertexB, vertexC );
            geometry2.faces.push( new THREE.Face3( 0, 1, 2 ) );

            var mesh = new THREE.Mesh( geometry2, material );
            mesh.position.sub( geometry2.center() );
            pieces.add( mesh );

          }

          //sort the pieces
          pieces.children.sort( function ( a, b ) {

            return a.position.z - b.position.z;
            //return a.position.x - b.position.x;     // sort x
            //return b.position.y - a.position.y;   // sort y

          } );

          pieces.rotation.set( 0, 0, 0 )

          return pieces;

        }

        var geom = new THREE.BoxGeometry( 20, 20, 20 );
        var color = new THREE.Color();

        var colors = [ 0x00ff00, 0x0000ff ]

        var matrix = new THREE.Matrix4();
        var quaternion = new THREE.Quaternion();

        var geometry = new THREE.BoxGeometry( 20, 20, 20 );

        function onWindowResize() {

          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          vrEffect.setSize( window.innerWidth, window.innerHeight );

        }

        window.addEventListener( 'resize', onWindowResize, false );

        var materials = [
          new THREE.MeshNormalMaterial()
          //new THREE.MeshBasicMaterial( { color: 0xeeeeee, shading: THREE.FlatShading, wireframe: true, transparent: true } )
        ];

        drawnObject = THREE.SceneUtils.createMultiMaterialObject( geometry, materials )

        scene.add( drawnObject );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor( 0xffffff, 1 );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.sortObjects = false;

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        raycaster = new THREE.Raycaster();

        cursor = new THREE.Cursor( camera, renderer );
        cursor.addEventListener('click', function() {
          if (INTERSECTED) {
            explodeBox(INTERSECTED);
            intersect();
          }
        });
        scene.add( cursor );
        scene.add( camera );
        vrControls = new THREE.VRControls(camera);
        vrEffect = new THREE.VREffect(renderer, VREffectLoaded);
        vrMode = false;
        function VREffectLoaded(error) {
          if (error) {
            fullScreenButton.innerHTML = error;
            fullScreenButton.classList.add('error');
          }
        }

        initSky();

        for ( var i = 0; i < 2000; i ++ ) {

          var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

          object.position.x = Math.random() * 800 - 400;
          object.position.y = Math.random() * 800 - 400;
          object.position.z = Math.random() * 800 - 400;
          if (object.position.z < 0) {
            object.position.z += cursor.pointer.position.z;
          } else {
            object.position.z -= cursor.pointer.position.z;
          }

          object.rotation.x = Math.random() * 2 * Math.PI;
          object.rotation.y = Math.random() * 2 * Math.PI;
          object.rotation.z = Math.random() * 2 * Math.PI;

          object.scale.x = Math.random() + 0.5;
          object.scale.y = Math.random() + 0.5;
          object.scale.z = Math.random() + 0.5;

          scene.add( object );
          objects.push( object );

        }

        fullScreenButton.onclick = function() {
          mouseLook = false;
          vrEffect.setFullScreen( true );
          vrMode = true;
          lockPointer();
        };

        var fullScreenChange =
          renderer.domElement.mozRequestFullScreen? 'mozfullscreenchange' : 'webkitfullscreenchange';

        document.addEventListener( fullScreenChange, onFullScreenChanged, false );
        function onFullScreenChanged() {
          if ( !document.mozFullScreenElement && !document.webkitFullScreenElement ) {
            document.exitPointerLock();
            vrMode = false;
            mouseLook = true;
          }
        }

        renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
        renderer.domElement.mozRequestPointerLock ||
        renderer.domElement.webkitRequestPointerLock;

      }

      //
      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }


      function render() {

        if (mouseLook) {
          controls.update();
        } else {
          vrControls.update();
        }
        if (vrMode) {
          intersect();
          vrEffect.render( scene, camera );
        } else {
          intersectMouse();
          renderer.render( scene, camera );
        }
        cursor.update();
        TWEEN.update();
      }

      document.addEventListener( 'keydown', function ( event ) {
        if (event.keyCode === 90) {
          vrControls.zeroSensor();
        }
      });

      function initSky() {

        // Add Sky Mesh
        sky = new THREE.Sky();
        scene.add( sky.mesh );

        var effectController  = {
          turbidity: 10,
          reileigh: 2,
          mieCoefficient: 0.005,
          mieDirectionalG: 0.8,
          luminance: 1,
          inclination: 0.49, // elevation / inclination
          azimuth: 0.25, // Facing front,
          sun: !true
        }

        var distance = 400000;

        function updateSky() {
          var uniforms = sky.uniforms;
          uniforms.turbidity.value = effectController.turbidity;
          uniforms.reileigh.value = effectController.reileigh;
          uniforms.luminance.value = effectController.luminance;
          uniforms.mieCoefficient.value = effectController.mieCoefficient;
          uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

          var theta = Math.PI * (effectController.inclination - 0.5);
          var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

          var x = distance * Math.cos(phi);
          var y = distance * Math.sin(phi) * Math.sin(theta);
          var z = distance * Math.sin(phi) * Math.cos(theta);

          uniforms.sunPosition.value.copy(new THREE.Vector3( x, y, z ));
        }

        updateSky();

      }

      // find intersections
      function intersect() {

        var vector = cursor.localToWorld( cursor.pointer.position.clone() );
        raycaster.set( camera.position, vector.sub( camera.position ).normalize() );

        var intersects = raycaster.intersectObjects( objects );

        if ( intersects.length > 0 ) {

          if ( INTERSECTED != intersects[ 0 ].object ) {

            if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

            INTERSECTED = intersects[ 0 ].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex( 0xffff00 );

          }

        } else {

          if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

          INTERSECTED = null;

        }
      }


      function intersectMouse() {

        var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        vector.unproject( camera );

        raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
        var intersects = raycaster.intersectObjects( objects );

        if ( intersects.length > 0 ) {

          if ( INTERSECTED != intersects[ 0 ].object ) {

            if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

            INTERSECTED = intersects[ 0 ].object;
            INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
            INTERSECTED.material.emissive.setHex( 0xffff00 );

          }

        } else {

          if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

          INTERSECTED = null;

        }

      }

    </script>

  </body>
</html>
