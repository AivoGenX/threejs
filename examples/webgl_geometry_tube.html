<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - extrude shapes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #222;
				margin: 0px;
				overflow: hidden;
			}
            #info {
				position: absolute;
				top : 0px;
                left: 50%;
                transform: translateX(-50%);
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}
			a {
				color: #f80;
			}
		</style>
	</head>

	<body>

		<script src="../build/three.js"></script>
        <script src="js/controls/TrackballControls.js"></script>
        <script src="js/controls/DragControls.js"></script>

        <script src='js/libs/dat.gui.min.js'></script>
        <script src="js/libs/stats.min.js"></script>
        
        <div id="info">
            <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - geometry tube<br>
            <label style="color: yellow">Drag points to modify the tube.</label>
        </div>

		<script>

            var camera, scene, renderer, controls, mesh, dragControls;
            var pointGroup = new THREE.Group();
            var size = 128;

            var parameters = {
                path: new THREE.CatmullRomCurve3( getInitialPoints() ),
                curve: 'CatmullRomCurve3',
                side: 'FrontSide',
                tubularSegments: 64,
                radius: 1,
                radialSegments: 8,
                closed: false,
                divisions: 5,
                opacity: 0.5
            };

            init();
            animate();

            function init() {

                renderer = new THREE.WebGLRenderer();
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0x222222 );

                scene.add( pointGroup );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.set( 0, 0, 10 );

                controls = new THREE.TrackballControls( camera, renderer.domElement );
                controls.minDistance = 200;
                controls.maxDistance = 500;

                scene.add( new THREE.AmbientLight( 0x222222 ) );

                var light = new THREE.PointLight( 0xffffff );
                light.position.copy( camera.position );
                scene.add( light );

                var gui = new dat.GUI( { width: 300 } );
                gui.add( parameters, 'tubularSegments', 3, 128, 1 ).name( 'Tubular Segments' ).onChange( updateObject );
                gui.add( parameters, 'radius', 0.1, 16, 0.01 ).name( 'Radius' ).onChange( updateObject );
                gui.add( parameters, 'radialSegments', 3, 16, 1 ).name( 'Radial Segments' ).onChange( updateObject );
                gui.add( parameters, 'closed' ).name( 'Closed' ).onChange( updateObject );

                gui.add( parameters, 'divisions', 2, 16, 1 ).name( "Divisions" ).onChange( setPoints );
                gui.add( parameters, 'opacity', 0, 1, 0.01 ).name( "Opacity" ).onChange( updateOpacity );

                gui.add( parameters, 'curve', [ 'CatmullRomCurve3', 'CubicBezierCurve3', 'LineCurve3', 'QuadraticBezierCurve3' ] ).name( 'Curve' ).onChange( updateObject );
                gui.add( parameters, 'side', [ 'FrontSide', 'BackSide', 'DoubleSide' ] ).name( 'Side' ).onChange( updateSide );


                stats = new Stats();
                document.body.appendChild( stats.dom );

                setPoints();

                mesh = new THREE.Mesh(
                    new THREE.TubeBufferGeometry(
                        parameters.path, parameters.tubularSegments, parameters.radius,
                        parameters.radialSegments, parameters.closed
                    ),
                    new THREE.MeshNormalMaterial( {
                        transparent: true,
                        opacity: 0.5
                    } )
                );
                scene.add( mesh );

                window.addEventListener( 'resize', onWindowResize, false );

                dragControls = new THREE.DragControls( pointGroup.children, camera, renderer.domElement );
                dragControls.addEventListener( 'dragstart', function () {

                    controls.enabled = false;

                } );
                dragControls.addEventListener( 'dragend', function () {

                    controls.enabled = true;
                    updateObject();

                } );

            }

            function updateSide() {

                mesh.material.side = THREE[ parameters.side ];

            }

            function updateOpacity() {

                mesh.material.opacity = parameters.opacity;

            }

            function updateObject() {

                if ( parameters.curve == 'LineCurve3' ) {

                    if ( pointGroup.children.length > 1 ) {

                        parameters.path = new THREE.LineCurve3( pointGroup.children[ 0 ].position, pointGroup.children[ 1 ].position );

                        while ( pointGroup.children.length > 2 ) {

                            removePoint( 2 );

                        }

                    }

                } else if ( parameters.curve == 'CubicBezierCurve3' ) {

                    if ( pointGroup.children.length > 3 ) {

                        parameters.path = new THREE.CubicBezierCurve3( pointGroup.children[ 0 ].position, pointGroup.children[ 1 ].position, pointGroup.children[ 2 ].position, pointGroup.children[ 3 ].position );

                        while ( pointGroup.children.length > 4 ) {

                            removePoint( 4 );

                        }

                    }

                } else if ( parameters.curve == 'QuadraticBezierCurve3' ) {

                    if ( pointGroup.children.length > 2 ) {

                        parameters.path = new THREE.QuadraticBezierCurve3( pointGroup.children[ 0 ].position, pointGroup.children[ 1 ].position, pointGroup.children[ 2 ].position );

                        while ( pointGroup.children.length > 3 ) {

                            removePoint( 3 );

                        }

                    }

                } else {

                    parameters.path = new THREE.CatmullRomCurve3( pointGroup.children.map( point => point.position ), parameters.closed );

                }

                mesh.geometry = new THREE.TubeBufferGeometry(
                    parameters.path, parameters.tubularSegments, parameters.radius,
                    parameters.radialSegments, parameters.closed
                );

            }

            function getInitialPoints() {

                var points = [];
                var a = Math.PI * 0.125;
                for ( var i = 0; i < 14; ++ i ) {

                    points.push( new THREE.Vector3( Math.cos( i * a ), Math.sin( i * a ), Math.cos( i * a ) ).multiplyScalar( 50 ) );

                }
                return points;

            }

            function removePoint( i ) {

                pointGroup.remove( pointGroup.children[ i ] );

            }

            function setPoints() {

                pointGroup.children.length = 0;
                var points = parameters.path.getPoints( parameters.divisions );
                for ( var i = 0; i < points.length; ++ i ) {

                    addPoint( points[ i ], i );

                }

            }

            function addPoint( position, i ) {

                var canvas = document.createElement( 'canvas' );
                canvas.width = 128;
                canvas.height = 128;

                var ctx = canvas.getContext( '2d', { alpha: false } );
                ctx.fillStyle = 'black';
                ctx.fillRect( 0, 0, size, size );
                ctx.fillStyle = 'white';
                ctx.font = ( size / 2 ) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText( i, size / 2, size / 2, size );

                var sprite = new THREE.Sprite( new THREE.SpriteMaterial( { map: new THREE.CanvasTexture( canvas ) } ) );
                sprite.scale.setScalar( 10 );
                sprite.position.copy( position );
                pointGroup.add( sprite );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );

                render();
                stats.update();

            }

            function render() {

                controls.update();

                renderer.render( scene, camera );

            }

            </script>
    </body>
</html>