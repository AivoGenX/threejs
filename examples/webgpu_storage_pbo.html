<html lang="en">
	<head>
		<title>three.js - WebGPU - Storage PBO Sorting</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Storage PBO Sorting
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
					"three/nodes": "./jsm/nodes/Nodes.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { storage, vec3, uv, uniform, uint, float, tslFn, instanceIndex, MeshBasicNodeMaterial } from 'three/nodes';

			import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
			import StorageBufferAttribute from 'three/addons/renderers/common/StorageBufferAttribute.js';

			init( );
			init( true );

			function init( forceWebGL = false ) {

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				// texture
				const phase = uniform( 1 );

				const size = 100;


				const array = [];
				for ( let i = 0; i < size; i ++ ) {

					// array[ i ] = THREE.MathUtils.randInt( 0, size );
					array[ i ] = i;
			
				}

				const arrayBuffer = new StorageBufferAttribute( new Float32Array( array ), 1 );

				const arrayBufferNode = storage( arrayBuffer, 'float', size, false );

				const computeInitRandom = tslFn( () => {

					const invertIndex = arrayBufferNode.element( float( size ).sub( instanceIndex ) ).toVar();
					// hash result is different between webgl and webgpu  because of precision
					// const index = float( instanceIndex.hash().mul( size ).floor() );
					arrayBufferNode.element( instanceIndex ).assign( invertIndex );

				} );

			

				// compute
			
			
				const computeInit = computeInitRandom().compute( size );

				const material = new MeshBasicNodeMaterial( { color: 0x00ff00 } );

				material.colorNode = tslFn( () => {

					const index = uint( uv().x.mul( float( size ) ) );

					const value = float( arrayBufferNode.element( index ) ).div( float( size ) ).mul( 20 ).floor().div( 20 );

					return vec3( value, value, value );

				} )();
			

				//
				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				const renderer = new WebGPURenderer( { antialias: false, forceWebGL: forceWebGL } );
				renderer.setPixelRatio( 1 );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( forceWebGL ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );
			
				} else {

					scene.background = new THREE.Color( 0x313131 );

				}
			
				// compute texture
				renderer.compute( computeInit );
			

				// const computeKernel = tslFn( ( ) => { // Assume currentPhase can be passed

				// 	// Calculate the index to consider based on the current phase
				// 	const pairIndex = instanceIndex.mul( 2 ).add( phase ).toVar();

				// 	// Ensure we're not accessing out of bounds
				// 	If( pairIndex.lessThan( uint( size ).sub( 1 ) ), () => {

				// 		const el = arrayBufferNode.element( pairIndex ).toVar();
				// 		const nextEl = arrayBufferNode.element( pairIndex.add( 1 ) );

				// 		// Swap if current element is greater than the next
				// 		If( el.greaterThan( nextEl ), () => {

				// 			arrayBufferNode.element( pairIndex ).assign( nextEl );
				// 			arrayBufferNode.element( pairIndex.add( 1 ) ).assign( el );

				// 		} );

				// 	} );

				// } );
				// const compute = computeKernel().compute( size );


				 const stepAnimation = async function () {

					// await renderer.computeAsync( compute );
					renderer.compute( computeInit );

					phase.value = ( phase.value + 1 ) % 2;

					// debug storage buffer WebGPU, webgl debug is in transferBufferToTexture
					// renderer.getArrayBufferAsync( arrayBuffer ).then( ( arrayBuffer ) => {

					// 	const dataview = new Float32Array( arrayBuffer );
					// 	console.log( 'arrayBuffer', dataview );

					// } );

					await renderer.renderAsync( scene, camera );

					setTimeout( stepAnimation, 1000 );
			
				};

				stepAnimation();
				// renderer.setAnimationLoop( stepAnimation );

				window.addEventListener( 'resize', onWindowResize );


				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.renderAsync( scene, camera );

				}

			}


		</script>
	</body>
</html>
