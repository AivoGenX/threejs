<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<base href="../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p class="desc">
			This article shows how to optimize your three.js scene.
		</p>

		<h2>Metrics</h2>

		<p>
			Before starting, we need to define a some metrics, and how to monitor them. There are two important factors
			that will affect your performances:

			<ul>
				<li>CPU: affects the number of frames per seconds (FPS) which represents how fluid is your scene</li>
				<li>Memory: affects the memory usage which can be restricted on low devices like smartphones</li>
			</ul>
		</p>

		<p>
			In order to monitor them you can use [mrdoob/stats.js](https://github.com/mrdoob/stats.js) repository.
		</p>

		<h2>Buffer Geometries</h2>

        <p>
            BufferGeometries store information (such as vertex positions, face indices, normals, colors,
            UVs, and any custom attributes) in [page:BufferAttribute buffers] - that is,
            [link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays typed arrays].
        </p>

        <p>
            If your are dealing with static scene, or a huge one and need to reduce memory usage you should rather use
            BufferGeometries instead of Geometries which are heavier.
        </p>

        <h2>Share Materials & Geometries</h2>

        <p>
            If you have multiple times the same object you want to repeat inside your scene. You muse share both material
            and geometry of that object in order to prevent memory overhead.
        </p>

        <code>
var geometry = new THREE.SphereBufferGeometry( 5, 32, 32 );
var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
var sphere;

for (var i = 0; i < 100; i++) {
    sphere = new THREE.Mesh( geometry, material );
    sphere.position.set( Math.random() * 100, Math.random() * 100, Math.random() * 100);

    scene.add( sphere );
}
        </code>

        <p>
            The counter-part is that when you modify the geometry or material, you modification will be applied to all
            instances.
        </p>

        <p>
            Note that using [page:Mesh.clone] will share geometry and material.
        </p>

		<h2>Disable Scene auto update</h2>

        <p>
            By default [page:Scene.autoUpdate] is set true meaning at each frame you will update the world matrix. This
            is fine for most of the cases but when you deal with huge scene and especially if
            [page:Object3D.matrixAutoUpdate] is set true, which is the default case this could have a very bad impact.
        </p>

        <p>
            If we have a look at the current implementation of the updateMatrixWorld. When [page:Object3D.matrixAutoUpdate]
            is true then all children matrices will be force updated.
        </p>

        <code>
updateMatrix: function () {

    this.matrix.compose( this.position, this.quaternion, this.scale );

    this.matrixWorldNeedsUpdate = true;

},

updateMatrixWorld: function ( force ) {

    if ( this.matrixAutoUpdate ) this.updateMatrix();

    if ( this.matrixWorldNeedsUpdate || force ) {

        if ( this.parent === null ) {

            this.matrixWorld.copy( this.matrix );

        } else {

            this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

        }

        this.matrixWorldNeedsUpdate = false;

        force = true;

    }

    // update children

    var children = this.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

        children[ i ].updateMatrixWorld( force );

    }

},
        </code>

        <p>
            In order to deal with this you can set [page:Scene.autoUpdate] false and manage your world matrices by calling
            [page:Object3D.updateMatrixWorld] when you update a property.
            You can also set [page:Object3D.matrixAutoUpdate] and call [page:Object3D.updateMatrix] before calling any
            [page:Object3D.updateMatrixWorld].
        </p>

		<h2>Textures</h2>

        <p>
            Textures can have a very big CPU and memory overhead. Three.js requires textures to be power of two. When
            three.js encounter a not power of two image, it will resize it which consume quite a lot CPU.
        </p>

        <p>
            You also need to take care of the device capabilities and especially the max texture size given by
            [page:WebGLRenderer.capabilities.maxTextureSize]. If your texture is higher than that then three.js will
            resize it.
        </p>

		<h2>Shadows</h2>

        <p>
            By default [page:WebGLRenderer.shadowMap.autoUpdate] is set true which will cause the shadow to update at
            each frame. If you know your scene is not intended to change at each frame, you can disable this and use
            [page:WebGLRenderer.shadowMap.needsUpdate] in order to trigger a recompute.
        </p>

        <h2>Power Preference</h2>

        <p>
            On devices with 2 GPU, generally integrated and dedicated the browser will by default use the integrated one
            in order to boost battery performance.

            If your scene requires a lot of performances, you can choose to use the dedicated GPU by using the
            **powerPreference** parameter of [page:WebGLRenderer].
        </p>

		<h2>New operator</h2>

        <p>
            Javascript is featured with a garbage collector to manage the memory. In standard projects we don't really
            need to care about this. But in 3D you are rendering your scene multiple time by second. If you create a lot
            of new objects at each frame, you will force the garbage collector to run more often causing a performance
            drop.
        </p>
	</body>
</html>
